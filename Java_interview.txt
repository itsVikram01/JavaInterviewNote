JAVA QUESTIONS :

OOPS : Polymorphism(Compile-time, Run-time), Inheritance(Single, Multilevel, Hierarchical), Encapsulation, Abstraction(using abstract class(0 to 100%) and interface(100%)).

Collection Framework : List(ArrayList, LinkedList),Queue(PriorityQueue),Set(HashSet, LinkedHashSet, TreeSet),Map(HashMap, LinkedHashMap, TreeMap)

String
Multi-threading
Exception Handeling

JAVA 8 : (Lambda Expressions, Functional Interfaces(Consumer, Predicate), Stream API, Default and Static Methods in Interfaces, Optional Class, Date and Time API, Method References)

Reading and Writing Files
Singleton class
	
Hibernate
MySQL : 
SPRINGBOOT :
Microservice : 

AngularJS :
Angular :

==================================================================================================================================================================================

public class Main {
  public static void main(String[] args) {
  }
}

. public: 
	This keyword indicates that the class Main can be accessed from any other code in the same project (or even different projects if it's in a specific package).

. class Main: 
	This declares a new class named Main. A class is a blueprint for creating objects, which encapsulate data (properties) and behavior (methods).

. public static void main(String[] args):
	This is the main method, which is the entry point of your Java program. When you run a Java program, the Java Virtual Machine (JVM) looks for the main method to start execution.

. public: 
	Same as before, this allows the JVM to access the main method.

. static: 
	This keyword means the main method can be called directly on the class itself (without creating an object of the class). This is important because the main method is typically used to perform actions before any objects are created.

. void: 
	This keyword specifies that the main method doesn't return any value.

. main(String[] args): 
	This is the method signature. It defines the name of the method (main), the parameters it takes (String[] args), and the return type (void).

. String[] args: 
	This is an array of strings that can be used to pass command-line arguments to your program. When you run a Java program from the command line, you can provide additional arguments after the program name. These arguments are stored in the args array. However, in this specific code example, args is not being used.
	
	
	
public static void main(String[] args) {} :
-------------------------------------------

1. public
	Access Modifier: The keyword public is an access modifier that makes the main method accessible from anywhere. This is necessary because the main method is the entry point of a Java application, and it must be accessible to the Java runtime environment to start the program.

2. static
	Static Method: The keyword static means that the method belongs to the class itself, rather than to instances of the class. This allows the Java runtime to call this method without creating an instance of the class. Since the main method is the entry point of the program, it must be static so that it can be called without having to instantiate the class.

3. void
	Return Type: The keyword void indicates that the main method does not return any value. The main method is designed to start the program and doesn't need to return any value to the calling process (the Java runtime).

4. main
	Method Name: main is the name of the method that the Java runtime environment searches for as the entry point of the program. The signature public static void main(String[] args) is predefined, and the runtime will look for this exact signature to begin execution.

5. String []args
	Parameter: The parameter String []args is an array of String objects. This array stores command-line arguments that are passed to the program when it is run. For example, if you run a program with java MyProgram arg1 arg2, the args array will contain ["arg1", "arg2"].

6. { }
	Method Body: The curly braces { } define the body of the main method. Inside these braces, you would write the code that you want to execute when the program starts.

==================================================================================================================================================================================


OOPS : 
------




	Encapsulation :
	---------------
		Binding (or wrapping) code and data together into a single unit are known as encapsulation. 
		It helps developers to follow modularity while developing software by ensuring that each object is independent of other objects by having its own methods, attributes, and functionalities.

		It is used for the security of the private properties of an object and hence serves the purpose of data hiding.

		For example, 
		a capsule, it is wrapped with different medicines.
		Java bean is the fully encapsulated class because all the data members are private here.


		code example -
			public class BankAccount {
			  private double balance; // Private attribute to store account balance
			  public double getBalance() { // Getter method to return balance
				return balance;
			  }
			  public void deposit(double amount) { // Setter method to deposit funds
				if (amount > 0) {
				  balance += amount;
				} //else {// Handle invalid deposit amount (optional)}
			  }
			  
			  public BankAccount(double initialBalance) { //constructor
				// Validate initial balance (optional)
				this.balance = initialBalance;
			  }

			  public void withdraw(double amount) { // Setter method to withdraw funds
				if (amount > 0 && amount <= balance) {
				  balance -= amount;
				} //else {// Handle invalid withdrawal amount (optional)}
			  }
			}


	Polymorphism : 
	--------------
		Polymorphism is the ability of objects to behave differently depending on the context in which it is used.
		OR
		If one task is performed in different ways then it is known as polymorphism. 
		OR
		Performing same operation differently in different class.

		For example: to convince the customer differently, to draw something(shape, triangle, rectangle, etc.)
		Another example can be to speak something : (a cat speaks meow, dog barks woof, etc.)

		Polymorphism can be achieved by --

		(1). Compile-time polymorphism(Overloading / Static Binding / Early Binding) :
			-->Two methods said to be overloaded if and only if both have same name but different signature(argument no or type). 
				eg- abs(int i){}
					abs(long l){}
					abs(float f){}
		
		
		(2). Run-time polymorphism(Overriding / Dynamic Binding / Late Binding) : 
			--> Overriding is a mechanism in which subclass provide its own implementation for a method that is already defined in its parent class.
			--> It occure at runtime when child class has same method name and same signature(argument no and type.)
			--> It also has same return type till 1.4v. But from 1.5v, the return type can be differ by co-varient relation(i.e. Parent to Child relation).
			
			Co-Varient : Applicable only for Object type not for Primitive type.
				Object --> Object / String / StringBuffer / ...
				Number --> Number / Integer / ...
				
			

		// main() method can't be overrided because it is static but it can use method hiding.
		. Method hiding : 
				If subclass has a static method with the same name and signature as a static method in its parent class. The subclass static method hides the parent class static method when called through a reference of the subclass type.
				
				class SuperClass {
				  public static void printMessage() {
					System.out.println("This is the message from SuperClass");
				  }
				}

				class SubClass extends SuperClass {
				  public static void printMessage() {
					System.out.println("This is the message from SubClass");
				  }
				}

				public class Main {
				  public static void main(String[] args) {
					SuperClass superRef = new SubClass(); // SubClass object with SuperClass reference
					SubClass subRef = new SubClass(); // SubClass object with SubClass reference

					superRef.printMessage(); // Output: This is the message from SuperClass (compile-time binding based on reference type)
					
					subRef.printMessage();  // Output: This is the message from SubClass (compile-time binding based on reference type)
				  }
				}

				
				
		
		Examples - 
			public class Animal {
				
				// makeSound() Method to be overridden
				public void makeSound() {
					System.out.println("Animal makeSound() method");
				}
				
				// Animal static main() method
				public static void main(String[] args) {
					System.out.println("Animal static main(String[] args) method");
				}
			}
			public class Parent extends Animal {
				// Data hiding of static main() method
				public static void main(String[] args) {
					System.out.println("Hiding Animal static main(String[] args) method with Parent static main(String[] args) method");
				}
				
				// Overloading main method
				public static void main(int[] args) {
					System.out.println("Overloading Parent static main(String[] args) method with Parent static main(int[] args)");
				}
				
				// Overriding
				@Override
				public void makeSound() {
					System.out.println("Overriding Animal makeSound() method with Parent makeSound() method");
				}
				
				// Parent static display() method
				public static void display() {
					System.out.println("Parent class static display() method");
				}
			}
			public class Child extends Parent {
				// Method hiding (Static method can not override but its data hiding)
				public static void main(String[] args) {
					System.out.println("Hiding Parent static main(String[] args) method with Child static main(String[] args) method");
				}
				
				// Method hiding of Parent static display() method with Child static display() method
				public static void display() {
					System.out.println("Hiding Parent static display() method with Child static display() method");
				}

				// Overloading
				public static void main(Float[] args) {
					System.out.println("Overloading Parent static main(String[] args) method with Child static main(Float[] args)");
				}
				public static void main() {
					System.out.println("Overloading Child static main(float[] args) method with Child static main() ");
				}
				
				// Overriding
				@Override
				public void makeSound() {
					System.out.println("Overriding Parent makeSound() method with Child makeSound() method");
				}
				
			}
			public class Main {
				public static void main(String[] args) {
					System.out.println("Main main method ");

					System.out.println("");
					Parent parent = new Parent();
					Parent parentChild =new Child();
					Child child = new Child();
					/*Child childParent = new Parent();*/ // Child class reference variable referencing a Parent class object not possible
					Animal animal = new Animal();

					parent.main(new String[0]); // Parent static main(String[] args) method
					parentChild.main(new String[0]); // Parent static main(String[] args) method
					parentChild.display(); // Parent class static display() method
					animal.makeSound(); // Animal makeSound() method

					//Overloading
					System.out.println("");
					System.out.println("Overloading :");
					parent.main(new int[0]); // Overloading Parent static main(String[] args) method with Parent static main(int[] args)
					child.main(new Float[0]); // Overloading Parent static main(String[] args) method with Child static main(Float[] args)
					child.main();   // Overloading Child static main(float[] args) method with Child static main()

					//Overriding
					System.out.println("");
					System.out.println("Overriding :");
					parent.makeSound(); // Overriding Animal makeSound() method with Parent makeSound() method
					parentChild.makeSound(); // Overriding Parent makeSound() method with Child makeSound() method
					child.makeSound(); // Overriding Parent makeSound() method with Child makeSound() method

					// Method hiding using class name
					System.out.println("");
					System.out.println("Method hiding using Class name :");
					Child.main(new String[0]);  // Hiding Parent static main(String[] args) method with Parent static main(String[] args) method
					Child.display(); // Hiding Parent static display() method with Child static display() method

					// Method hiding using object
					System.out.println("");
					System.out.println("Method hiding using object :");
					child.main(new String[0]); // Hiding Parent static main(String[] args) method with Parent static main(String[] args) method

				}
			}





	Inheritance (IS-A relationship) in OOPs :
	-----------------------------------------
		"Reusability of programming code by inheriting the property of another class"

		‘IS-A’ relationship is another name for inheritance. 
		When we inherit the base class from the derived class, then it forms a relationship between the classes. So that relationship is termed an ‘IS-A’ Relationship.

		Example - Consider a Television (Typical CRT TV). Now another Smart TV  that is inherited from television class. So we can say that the Smart tv is also a TV. 
		Because CRT TV things can also be done in the Smart TV.

		So here ‘IS-A’ Relationship formed. [ SmartTV ‘IS-A’ TV ].


		In inheritance classes are devide into 2 category -
		(1). Parent class(Base class / Super class) :
		(2). Child class(Derived class / Sub class / Extended class


		Type of Inheritance :
		---------------------
			(1). Single inheritance : 
			-------------------------
				class Animal {
					public void eat() {
					System.out.println("Animal is eating");
					}
				}
				class Dog extends Animal {
					public void bark() {
						System.out.println("Dog is barking");
					}
				}
				public class Main {
					public static void main(String[] args) {
						Dog d = new Dog();
						d.eat();  // Inherited from Animal
						d.bark(); // Specific to Dog
					}
				}

			(2). Multilevel inheritance : 
			-----------------------------
				class Vehicle {
					public void move() {
						System.out.println("Vehicle is moving");
					}
				}
				class Car extends Vehicle {
					public void honk() {
						System.out.println("Car is honking");
					}
				}
				class SportsCar extends Car {
					public void accelerate() {
						System.out.println("Sports car is accelerating");
					}
				}
				public class Main {
					public static void main(String[] args) {
					SportsCar sc = new SportsCar();
						sc.move();  // Inherited from Vehicle
						sc.honk();  // Inherited from Car
						sc.accelerate(); // Specific to SportsCar
					}
				}
				
				
			(3). Hierarchical inheritance : 
			-------------------------------
				class Shape {
					public void draw() {
						System.out.println("Drawing a shape");
					}
				}
				class Circle extends Shape {
					public void roll() {
						System.out.println("Circle is rolling");
					}
				}
				class Rectangle extends Shape {
					public void calculateArea() {
						System.out.println("Calculating area of rectangle");
					}
				}
				public class Main {
					public static void main(String[] args) {
						Circle c = new Circle();
						c.draw();  // Inherited from Shape
						c.roll();  // Specific to Circle

						Rectangle r = new Rectangle();
						r.draw();  // Inherited from Shape
						r.calculateArea(); // Specific to Rectangle
					}
				}




		Notes : 
		-------
		Java does not  support multiple inheritance for classes due to Complexity and ambiguity : 
			With multiple inheritance, a subclass can inherit from multiple parent classes. If both parent classes have methods with the same name then this can lead to ambiguity. The compiler wouldn't know which method to call from the subclass. This is often referred to as the "diamond problem".


		We can achieve code reuse and functionality similar to multiple inheritance by using Composition(has-a relationship) and Interfaces.
		
		Composition :
		-------------
			Composition refers to a technique for creating complex objects by combining simpler objects. It's a way to establish a "has-a" relationship between objects.
			eg.
				public class Engine {
				  public void start() {
					// Simulate engine starting
					System.out.println("Engine started!");
				  }
				}
				public class Wheel {
				  public void roll() {
					// Simulate wheel rolling
					System.out.println("Wheel rolling!");
				  }
				}
				public class Car {
				  private Engine engine;  // Car has-a Engine
				  private Wheel[] wheels;  // Car has-a array of Wheels

				  public Car(Engine engine, Wheel[] wheels) {
					this.engine = engine;
					this.wheels = wheels;
				  }

				  public void startAndDrive() {
					engine.start();
					for (Wheel wheel : wheels) {
					  wheel.roll();
					}
				  }
				  
				}




	Abstraction :
	-------------
		Hiding internal details and showing only essential functionality is known as abstraction. 
		OR
		"Process of representing only essential features". It allows developers to hide complex implementation details.

		For example phone call, we don't know the internal processing.


		In Java, we use abstract class and interface to achieve abstraction.

		1.Abstract class : (0 to 100% abstraction achieved) 
		----------------------------------------------------
			abstract modifier is applicabe for methods and classes only but not for variables.
			
			. abstract method : 
				These are methods declared without implementation in an abstract class or interface. 
				
			. abstract class : 
				"Special type of class which does not provide a complete implementation for abstract methods present in it, hence cannot be instantiated using new keyword".
				abstract class contain both abstract and non-abstract methods as well as instance variable and constructors.
				Concrete subclasses are classes that provide concrete implementation for all the abstract methods defined in parent abstract class.
				
				example - 
					public abstract class Shape { // abstract class
						public abstract double calculateArea(); // abstract method
					}
					public class Circle extends Shape { // cannot use protected/private access modifier with Child class(Concrete subclass)
						private final double radius;
						public Circle(double radius) {
							this.radius = radius;
						}

						@Override
						public double calculateArea() { // concrete implementation of Parent abstract method calculateArea() by concrete subclass Circle
							return Math.PI * radius * radius;
						}
					}
					public class Main {
						public static void main(String[] args) {
							Circle circle = new Circle(5); // Object creation Of Circle class using Circle class refernce
							System.out.println("Circle Area: " + circle.calculateArea());
						}
					}
		
		

		2.Interface : (100% abstraction achieved) 
		-----------------------------------------
			Interface are any Service Requirement Specification(SRS) which are  collection of abstract methods and constant fields.
			It does not provide implementation of any methods. 
			
			To define an interface in java we use "interface" keyword followed by interface name.
			Example - 
				public interface Shape {
					double calculateArea(); // Abstract method - needs implementation in implementing class

					default void printInfo() { // Default method with implementation
						System.out.println("This is a shape object.");
					}

					static double calculateTotalArea(Shape[] shapes) { // Static method - can be called directly using interface name
						double totalArea = 0;
						for (Shape shape : shapes) {
							totalArea += shape.calculateArea();
						}
						return totalArea;
					}
				}
				public class Circle implements Shape {
					private double radius;
					
					public Circle(double radius) {
						this.radius = radius;
					}

					@Override
					public double calculateArea() {
						return Math.PI * radius * radius;
					}

					// Can override the default method if needed
					@Override
					public void printInfo() {
						System.out.println("This is a circle object with radius: " + radius);
					}
				}
				public class Main {
					public static void main(String[] args) {
						Circle circle1 = new Circle(5);
						Circle circle2 = new Circle(3);

						System.out.println("Circle 1 Area: " + circle1.calculateArea()); // Calling abstract method through object

						circle1.printInfo(); // Calling default method through object (can be overridden)

						System.out.println("Total Area of both circles: " + Shape.calculateTotalArea(new Shape[]{circle1, circle2})); // Calling static method directly using interface name
					}
				}

	

		 

		Adapter class : 
		---------------
			Adapter class is a class which provide empty implementation of every method present in interface.

			interface MyInterface {
				m1();
				m2();
				.
				.
				m1000();
			}
			abstract class MyAdapter implements MyInterface {
				m1(){}
				m2(){}
				.
				.
				m1000(){}
			}
			class Test extends MyAdapter {
				m1(){
					//code
				}
			}
			class Dummy extends MyAdapter {
				m1000(){
					//code
				}
			}



			Withought using Adapter class : 
			we have to provide implementation of every method of interface in every class which implements Interface.
			class WithoutAdapter implements MyInterface {
				m1(){//code}
				m2(){//code}
				.
				.
				m1000(){//code}
			}





		Functional interface :
			. functional interface is an interface that contains exactly one abstract method. They are also known as Single Abstract Method (SAM) interfaces.
				
				@FunctionalInterface
				public interface Square {
				  int square(int x);
				}
				
				@FunctionalInterface
				public interface StringComparator {
					int compare(String str1, String str2);
				} //  This StringComparator interface has a single abstract method compare that takes two strings (a and b) and returns an integer indicating their relative order (-1 if a is less than b, 0 if they are equal, 1 if a is greater than b).
				
				public class Main {
					public static void main(String[] args) {
						List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

						// Using lambda expression:
						Square squareLambda = x -> x * x;
						List<Integer> squaresLambda = numbers.stream().map(squareLambda).collect(Collectors.toList());
						System.out.println("Squares (lambda): " + squaresLambda); // Output: [1, 4, 9, 16, 25]

						// Using method reference (corrected):
						Square squareRef = Math::pow; // Correct method reference for squaring (power with 2)
						List<Integer> squaresRef = numbers.stream().map(squareRef.apply(2)).collect(Collectors.toList()); // Apply method reference with second argument (2)
						System.out.println("Squares (method reference): " + squaresRef); // Output: [1, 4, 9, 16, 25]
						
						
						
						
						List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
						// Lambda expression for alphabetical order (ascending)
						StringComparator alphabeticalOrder = (str1, str2) -> str1.compareTo(str2);
						// Sort the list using the lambda expression
						List<String> sortedNames = names.stream()
													   .sorted(alphabeticalOrder)
													   .collect(Collectors.toList());
						System.out.println("Sorted names (ascending): " + sortedNames);
					}
				}
				
		


			. Optional default and static methods: 
				. Functional interface can have any number of default and static methods. These methods provide default implementations or utility functions that can be reused across implementations.
				
				@FunctionalInterface
				public interface MathOperations {
					// Abstract method requiring implementation in concrete classes
					int add(int x, int y);
					// Default method providing a default implementation for subtract
					default int subtract(int x, int y) {
						return x - y;
					}
					// Static method as a utility function
					static int multiply(int x, int y) {
						return x * y;
					}
				}
				public class Calculator implements MathOperations {
					@Override
					public int add(int x, int y) {
						return x + y;
					}
					// Not required to implement subtract as it has a default implementation
				}
				public class Main {
					public static void main(String[] args) {
						MathOperations calculator = new Calculator();
						int sum = calculator.add(5, 3);
						int difference = calculator.subtract(10, 2); // Using default implementation
						int product = MathOperations.multiply(4, 6); // Calling static method
						System.out.println("Sum: " + sum);
						System.out.println("Difference: " + difference);
						System.out.println("Product: " + product);
					}
				}

			Note... @FunctionalInterface annotation is not mandatory but recommended for functional interfaces. It improves code clarity.



			Benefits of functional interfaces:
			-----------------------------------
				. Concise and readable code: 
				----------------------------
					Lambda expressions and method references can be used to provide compact implementations for functional interfaces, leading to cleaner and more readable code.
					
					@FunctionalInterface
					public interface StringModifier {
						String modify(String str); // abstract method requiring implementation
					}
					public class StringModifierImpl implements StringModifier {
						@Override
						public String modify(String str) { // StringModifierImpl override StringModifier abstract method and provide implementation
							// Your string modification logic here (e.g., uppercase, reverse)
							return str.toUpperCase();
						}
					}
					public class Main {
						public static void main(String[] args) {
							String hello = "Hello, world!";

							// Using lambda expression with StringModifierImpl
							StringModifier modifier = new StringModifierImpl();
							String modifiedString = modifier.modify(hello);
							System.out.println(modifiedString); // HELLO, WORLD!


							// OR


							// define the lambda expressions or method references directly within the Main class. These expressions provide the implementation for the modify method on the fly. While this approach keeps the logic within Main, it might slightly decrease readability for more complex modifications.
							// Using lambda expression directly using FunctionalInterface
							StringModifier toUpperCase = str -> str.toUpperCase();
							StringModifier reverse = str -> new StringBuilder(str).reverse().toString();

							String result1 = toUpperCase.modify(hello);
							String result2 = reverse.modify(hello);

							System.out.println("Uppercase: " + result1); // Uppercase: HELLO, WORLD!
							System.out.println("Reversed: " + result2); // Reversed: !dlrow ,olleH

							// Using method reference
							StringModifier trimSpaces = String::trim;
							String trimmedGreetings = trimSpaces.modify(hello);
							System.out.println("Trimmed: " + trimmedGreetings); // Trimmed: Greetings from Java!
						}
					}


				. Improved functional programming style: 
				----------------------------------------
					Functional interfaces enable a more functional programming paradigm in Java, allowing you to write code that focuses on what needs to be done rather than how.
					
					@FunctionalInterface
					public interface IntegerOperation {
						int operation(int a, int b);
					}
					public class Main {
						public static void main(String[] args) {
							int[] numbers = {1, 2, 3, 4, 5};

							// Imperative Approach : 
							int sum = 0;
							for (int number : numbers) { // Iterate through the array and add each element to the sum
								sum += number;
							}
							System.out.println("Sum: " + sum);


							// OR

							//Functional Approach :
							IntBinaryOperator sum1 = (a, b) -> a + b; // Define a lambda expression for addition
							//IntBinaryOperator sum1 = Integer::sum; // method reference

							// Use the operation on the entire array with reduce()
							int totalSum = IntStream.of(numbers).reduce(0, sum1); // Initial value is 0
							System.out.println("Sum: " + totalSum);
						}
					}

				. Higher-order functions: 
				-------------------------
					Functional interfaces play a vital role in using higher-order functions, which take functions as arguments or return functions as results. This enables powerful abstractions and composability.
						
						@FunctionalInterface
						public interface IntegerOperation {
							int operation(int a, int b);
						}
						public class Main {
							public static void main(String[] args) {
								String[] names = {"Alice", "Bob", "Charlie", "David", "Emily"};

								// Filter names starting with "A" (higher-order function)
								List<String> filteredNames = filter(names, name -> name.startsWith("A"));
								System.out.println("Names starting with A: ");
								for (String name : filteredNames) {
									System.out.println(name);
								}
							}

							// Higher-order function that takes a NameFilter as argument
							public static List<String> filter(String[] names, NameFilter filter) {
								List<String> filteredList = new ArrayList<>();
								for (String name : names) {
									if (filter.test(name)) {
										filteredList.add(name);
									}
								}
								return filteredList;
							}
						}




		Some common examples of functional interfaces:
		----------------------------------------------
			Function : 
			-----------
				The Function is a functional interface in Java that represents a function that takes one argument of a specific type and returns a value of another type. It's a versatile interface used in various functional programming concepts like streams and higher-order functions.
			
					. java.util.function.Function<T, R>: 
					------------------------------------
						This represents a function that takes one argument of type T and returns a value of type R.
						
						@FunctionalInterface
						public interface Function<T, R> {
							R apply(T t); // Here, T is the type of the input argument.
						}
						public class Main {
							public static void main(String[] args) {
								
								// Functions with Lambda Expressions:
								Function<Integer, Integer> doubler = x -> x * 2; // Function to double a number
								int result = doubler.apply(5); // Apply the function to 5
								System.out.println("Double of 5: " + result); // Output: 10
								
								Function<String, String> toUpperCase = String::toUpperCase; // Function to convert a string to uppercase
								String message = "Hello, world!";
								String uppercasedMessage = toUpperCase.apply(message);
								System.out.println("Uppercased message: " + uppercasedMessage); // Output: HELLO, WORLD!
								
								
								// Higher-Order Functions:
								List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
								List<String> uppercasedNames = transformList(names, String::toUpperCase);  // Uppercase all names
								
								// Method References:
								Function<Integer, String> intToString = String::valueOf;  // Convert int to String
								String numberString = intToString.apply(100);  // numberString will be "100"

							}
							
							public static <T, R> List<R> transformList(List<T> list, Function<T, R> transformer) {
								List<R> transformedList = new ArrayList<>();
								for (T element : list) {
									transformedList.add(transformer.apply(element));
								}
								return transformedList;
							}

						}


			Consumer : 
			----------
				A Consumer is a functional interface that accepts a single input argument and performs some operation on it. It does not return any result.
				. Use Consumer to perform actions on objects without returning a value.

					. java.util.function.Consumer<T>: 
					---------------------------------
						This represents an operation that takes one argument of type T but doesn't return a value (void).
						@FunctionalInterface
						public interface Consumer<T> {
							void accept(T t); // Here, T is the type of the input argument.
						}
						public class Main {
							public static void main(String[] args) {
								// Consumer to print a message
								Consumer<String> printer = System.out::println;
								printer.accept("This is a message to be printed."); // Output: This is a message to be printed.

								// Consumer to modify a string in-place (assuming a mutable String implementation)
								Consumer<StringBuilder> modifier = sb -> sb.append(" (modified)");
								StringBuilder message = new StringBuilder("Original message");
								modifier.accept(message);
								System.out.println(message); // Output: Original message (modified)
								
								Consumer<String> printConsumer = (String s) -> System.out.println(s);
								printConsumer.accept("Hello, World!"); // Output: Hello, World!
								
								//. Processing elements in a collection, like printing each element.
								//. Performing an action on each element of a stream.
								List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
								names.forEach((String name) -> System.out.println(name));
								Consumer<String> printNames = name -> System.out.println(name.toUpperCase());
								names.forEach(printNames);
							}
						}


			
			Predicate : 
			-----------
				. A Predicate is a functional interface that represents a predicate (boolean-valued function) of one argument.
				. A Predicate represents a function that takes an argument and returns a boolean value.
				. It's used to test a condition on the input.	
				
				. Use Predicate to test conditions on objects and return true or false.


					. java.util.function.Predicate<T>: 
					----------------------------------
						This represents a function that takes one argument of type T and returns a boolean value.
						
						@FunctionalInterface
						public interface Predicate<T> {
							boolean test(T t); // Here, T is the type of the input argument.
						}
						public class Main {
							public static void main(String[] args) {
								// Predicate to check if a number is even
								Predicate<Integer> isEven = x -> x % 2 == 0;
								int number = 10;
								boolean isEvenNumber = isEven.test(number);
								System.out.println(number + " is even: " + isEvenNumber); // Output: 10 is even: true

								// Predicate to check if a string starts with "Java"
								Predicate<String> startsWithJava = str -> str.startsWith("Java");
								String text = "Java programming language";
								boolean startsWith = startsWithJava.test(text);
								System.out.println(text + " starts with 'Java': " + startsWith); // Output: Java programming language starts with 'Java': true
								
										
								Predicate<Integer> isEven = (Integer i) -> i % 2 == 0;
								System.out.println(isEven.test(4)); // Output: true
								System.out.println(isEven.test(5)); // Output: false
								
												
								//. Filtering elements in a collection or stream.
								//. Defining conditions for elements.
								List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
								
								Predicate<Integer> isGreaterThan5 = num -> num > 5;
								List<Integer> greaterNumbers = numbers.stream()
																	.filter(isGreaterThan5)
																	.forEach(System.out::println);
								System.out.println(greaterNumbers);
																	
								Predicate<Integer> isEven = (Integer i) -> i % 2 == 0;
								List<Integer> evenNumbers = numbers.stream()
																	.filter(isEven)
																	.collect(Collectors.toList());
								System.out.println(evenNumbers); // Output: [2, 4, 6]
							}
						}





		Comparator : 
		------------
			The Comparator interface is found in the java.util package and has a single method compare. 
			Comparator interface is used to define the order of objects. It's particularly useful when you want to sort collections or arrays of objects in a specific order that is different from their natural order (defined by the Comparable interface). 
			
				public class Product {
					private String name;
					private double price;
					// Getters and setters for name and price
				}
				public class Main {
					public static void main(String[] args) {
						List<Product> products = Arrays.asList(new Product("Laptop", 800.00), 
																new Product("Phone", 500.00), 
																new Product("Headphones", 100.00));
						// Comparator for sorting by price (ascending)
						Comparator<Product> priceComparator = (product1, product2) -> Double.compare(product1.getPrice(), product2.getPrice());
						
						// Sort the list using the comparator
						List<Product> sortedProducts = products.stream()
																.sorted(priceComparator)
																.collect(Collectors.toList());
						System.out.println("Products sorted by price (ascending):");
						for (Product product : sortedProducts) {
							System.out.println(product);
						}
					}
				}

			

		Marker interface : 
			Marker interface is an interface which doesn't contain any method but objects will get some ability by implementing them.
			For example : 
				Serializable(I) : 
				-----------------
					public class Person implements Serializable {
						// Person class fields and methods
					}
					
					//. Person class implements the Serializable interface. This indicates that objects of the Person class can be converted into a stream of bytes for storage or transmission over a network. The Serializable interface itself doesn't provide any methods, but implementing it tells the JVM that the class can be serialized.
					
				Cloneable(I) : 
				--------------
					public class Document implements Cloneable {
						// Document class fields and methods
						@Override
						public Object clone() throws CloneNotSupportedException {
							// Implement logic to create a copy of the Document object
							return super.clone();
						}
					}
					
					//. The Document class implements the Cloneable interface. This interface signifies that objects of the Document class can be cloned. However, it's important to note that the Cloneable interface doesn't define how the cloning should be done. Classes that implement Cloneable must also override the clone() method from the Object class to provide the actual cloning implementation.
					
				RandomAccess(I) : 
				-----------------
					public class MyArrayList implements List<String> {
						private List<String> data; // Internal data storage

						// Implement List interface methods (add, remove, etc.)
						@Override
						public String get(int index) {
							// Efficient access using index
							return data.get(index);
						}
					}
					
					//. MyArrayList implements the List<String> interface as well as the RandomAccess interface.
					//. This indicates that the MyArrayList can efficiently access elements using their index (get(int index)) because it maintains an underlying data structure that allows for constant time lookups.
					//. Implementations like ArrayList in the Java Collections Framework utilize arrays for data storage, enabling random access.
					
				SingleThreadModel(I) : 
				----------------------
					public class MySingleThreadServlet extends HttpServlet implements SingleThreadModel {
						@Override
						protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
							// Process the request in this single thread
							resp.getWriter().println("This request is processed in a single thread.");
						}
					}
					
					//. MySingleThreadServlet extends HttpServlet and implements SingleThreadModel.
					//. This ensures that even if multiple requests come in for this servlet, only one thread will handle a request at a time for a specific instance. This can be useful for situations where you need to maintain state or avoid race conditions across requests.
					//. The server might create multiple instances of the servlet to handle concurrent requests efficiently.
										


===========================================================================================


	COLLECTION FRAMEWORK : 
	----------------------

	Iterable interface : (Parent interface of Collection framework.)
	--------------------
		. The Iterable interface establishes a contract between a Collection class and code that needs to iterate over its elements. By implementing Iterable, a Collection class guarantees that it can provide an iterator object, which allows you to access elements sequentially.
		
		. iterator() method: The Iterable interface has a single abstract method:
			public Iterator<T> iterator();
			
		This method returns an Iterator object. 
		The Iterator interface provides methods for traversing the elements in the collection, such as hasNext() to check if there are more elements and next() to get the next element.
		
		Benefits of Iterable:
		. Uniform Iteration: 
			Iterable provides a consistent way to iterate over various collection classes (like ArrayList, HashSet, etc.) using the same syntax (e.g., for-each loop). This simplifies code and improves readability.
		. Decoupling: 
			The Iterable interface separates the concept of a collection (data structure) from the iteration logic. This promotes cleaner code and allows for different iteration strategies.

		public class MyList implements Iterable<String> {
		  private List<String> elements = new ArrayList<>();
		  public void add(String element) {
			elements.add(element);
		  }
		  @Override
		  public Iterator<String> iterator() {
			return elements.iterator(); // Return the iterator of the underlying list
		  }
		  public static void main(String[] args) {
			MyList myList = new MyList();
			myList.add("Apple");
			myList.add("Banana");
			myList.add("Cherry");
			
			// Iterate using a for-each loop (works because MyList implements Iterable)
			for (String fruit : myList) {
			  System.out.println(fruit);
			}
		  }
		}



	Collection interface : 
	-----------------------
		Collection interface in Java lies at the heart of the Java Collections Framework.
		
		Collection defines a collection as a group of elements, typically of the same type. It doesn't specify how the elements are stored internally (e.g., ordered vs. unordered).
		
		Collection extends the Iterable interface, inheriting the iterator() method for iterating over elements.
		Collection has several subinterfaces that define more specific collection types like List (ordered collections), Set (unordered collections that don't contain duplicates), and Queue (collections that follow a specific order for insertion and removal of elements).
		
		It provides a set of methods for performing common operations on collections, including:
		. add(E element): Adds an element to the collection.
		. remove(Object o): Removes an element from the collection.
		. contains(Object o): Checks if the collection contains a specific element.
		. isEmpty(): Checks if the collection is empty.
		. size(): Returns the number of elements in the collection.
		. clear(): Removes all elements from the collection.
		. iterator(): Returns an Iterator object to iterate over elements.
		
		Benefits of Collection:
		-----------------------
		. Standardized Interface :
			By implementing Collection, various collection classes provide a consistent set of operations, making it easier to work with different collection types using the same syntax.
		. Code Reusability :  
			 Code that operates on collections can be written generically to work with any class that implements Collection, promoting code reusability and maintainability.

		Subinterfaces:
		--------------
			. List: 
			-------
				. Ordered Collection: Elements are maintained in the order they were added.
				. Duplicates Allowed: You can have multiple instances of the same element in a List.
				. Indexed Access: You can access elements directly using their position (index) in the List. This starts from 0 (zero).
				. Common Implementations: ArrayList (fast random access), LinkedList (faster insertion and deletion).
			
			. Queue: 
			--------
				. Unique Order: The Queue interface prioritizes order of insertion (First-In-First-Out, FIFO). The order elements are added in is the order they are retrieved.Elements are added at the back (enqueue) and removed from the front (dequeue). eg. A line where the first person in line gets served first. 
				. Duplicates Allowed: Some Queue implementations may not allow duplicates, depending on the specific implementation.
				. Common Implementations: LinkedList (basic Queue implementation allows duplicates), PriorityQueue (prioritizes elements based on a custom order and allows duplicates)
					
					. Deque: 
						Extends Queue and provides additional methods for inserting and removing elements from both ends. (e.g., ArrayDeque)
						
			. Set: 
			------
				. Unordered Collection: Elements are not stored in any specific order.
				. No Duplicates: A Set cannot contain duplicate elements. If you try to add a duplicate, it's simply ignored.
				. Unique Values: Sets are useful when you only care about distinct elements and not their order.
				. Common Implementations: HashSet (fast average-case performance), LinkedHashSet (maintains insertion order), TreeSet (sorts elements based on a natural order or custom comparator).
			
			. Map: 
			------
				. Key-Value Pairs: A Map stores key-value pairs. Keys are unique identifiers used to access the corresponding values.
				. Unordered: The order elements are added in is not preserved.
				. Key is unique and value can be duplicate.
				. Fast Retrieval: You can efficiently retrieve a value by its key.
				. Common Implementations: HashMap (fast average-case performance), LinkedHashMap (maintains insertion order), TreeMap (sorts keys based on a natural order or custom comparator).

			
		Subclasses:
		-----------
			. ArrayList: (implements List)
			------------
				. Uses an underlying array for storage.	
				. Pros : Fast random access (get element by index), efficient for adding elements to the end.
				. Cons : Resizing the array can be slow for frequent insertions/deletions in the middle. Not thread-safe.
			
			. LinkedList: (implements List, Deque)
			-------------
				. Uses doubly-linked nodes to store elements.
				. Pros : Faster insertions/deletions anywhere in the list.
				. Cons : Slower random access (needs to traverse nodes to find index). Not thread-safe.
				
			. HashSet: (implements Set)
			----------
				. Uses a hash table for fast average-time lookups.
				. Pros : Unbeatable for checking if an element exists (contains method). Not ordered (insertion order not preserved).
				. Cons : Doesn't allow duplicate elements. Not suitable when order matters. Not thread-safe.
			
			. TreeSet: (implements Set, SortedSet)
			----------
				. Stores elements in a sorted order based on their natural ordering or a custom comparator.
				. Pros : Efficient for finding elements within a specific range (subSet method). Ordered set.
				. Cons : Slower average-case lookups compared to HashSet. Not suitable when order doesn't matter. Not thread-safe.
			
			. HashMap: (implements Map)
			----------
				. Uses a hash table for fast average-time lookups based on keys.
				. Pros : Unbeatable for retrieving values by key. Not ordered (key-value pairs not stored in insertion order).
				. Cons : Doesn't allow duplicate keys. Not suitable when order matters. Not thread-safe. 
					
			. TreeMap: (implements Map, SortedMap)
			----------
				. Stores key-value pairs in a sorted order based on the natural ordering of keys or a custom comparator.
				. Pros : Efficient for iterating over key-value pairs in sorted order.
				. Cons : Slower average-case lookups compared to HashMap. Not suitable when order doesn't matter. Not thread-safe.


		Choosing the Right Collection :
		. Random access and frequent modifications in the middle: ArrayList for good balance, LinkedList for more insertions/deletions.
		. Fast lookups and don't care about order: HashSet for Sets, HashMap for Maps.
		. Need sorted elements: TreeSet for Sets, TreeMap for Maps.
		. Thread-safety is a concern: Consider using synchronized versions of these collections or thread-safe alternatives like ConcurrentHashMap.



		example --
		
		import java.util.*;
		public class CollectionSubinterfacesExample {
			public static void main(String[] args) {

				// List (ArrayList) - Ordered collection, duplicates allowed
				List<Integer> numbersList = new ArrayList<>();
				numbersList.add(10);
				numbersList.add(5);
				numbersList.add(15);
				numbersList.add(5); // Duplicates allowed

				System.out.println("Numbers List (ArrayList): " + numbersList); // [10, 5, 15, 5] 
				
				// List (LinkedList) - Doubly-linked list, efficient for insertions/removals at any position
				List<String> colorsList = new LinkedList<>();
				colorsList.add("Red");
				colorsList.add(0, "Green"); // Efficient insertion at index 0
				colorsList.add("Blue");

				System.out.println("Colors List (LinkedList): " + colorsList); // [Green, Red, Blue]

				// List (Vector) - Thread-safe version of ArrayList (mostly legacy, use ArrayList for new code)
				List<Integer> agesList = new Vector<>();
				agesList.add(25);
				agesList.add(30);
				agesList.add(20);

				System.out.println("Ages List (Vector): " + agesList); // [25, 30, 20]

				// List (Stack) - LIFO (Last-In-First-Out) order for element access (consider using Deque for more flexibility)
				List<String> booksStack = new Stack<>();
				booksStack.push("Java for Beginners");
				booksStack.push("Data Structures and Algorithms");
				booksStack.push("Software Design Patterns");

				System.out.println("Books Stack: " + booksStack); // [Software Design Patterns, Data Structures and Algorithms, Java for Beginners] (top element first)
				
				
				
				// Queue (PriorityQueue) - Elements prioritized based on natural ordering or comparator (default: min heap)
				Queue<String> tasksQueue = new PriorityQueue<>();
				tasksQueue.offer("High priority task");
				tasksQueue.offer("Normal priority task");
				tasksQueue.offer("Urgent task"); // Urgent task will be processed first

				System.out.println("Tasks Queue (PriorityQueue): " + tasksQueue); // [Urgent task, High priority task, Normal priority task] (order based on priority)
				
				// Queue (LinkedList) - Can also be used as a Queue (FIFO - First-In-First-Out)
				Queue<Integer> numbersQueue = new LinkedList<>();
				numbersQueue.offer(1);
				numbersQueue.offer(3);
				numbersQueue.offer(2);

				System.out.println("Numbers Queue (LinkedList): " + numbersQueue); // [1, 3, 2] (FIFO order)

				// Queue (ArrayDeque) - Array-based Deque, efficient for adding/removing from both ends
				Queue<Character> charsQueue = new ArrayDeque<>();
				charsQueue.add('A');
				charsQueue.add('B');
				charsQueue.addLast('C');

				System.out.println("Characters Queue (ArrayDeque): " + charsQueue); // [A, B, C] (FIFO order)

				// Queue (ConcurrentLinkedQueue) - Thread-safe Queue implementation
				Queue<String> tasksQueue = new ConcurrentLinkedQueue<>();
				tasksQueue.offer("Task 1");
				tasksQueue.offer("Task 2");
				tasksQueue.offer("Task 3");

				System.out.println("Tasks Queue (ConcurrentLinkedQueue): " + tasksQueue); // [Task 1, Task 2, Task 3] (FIFO order, thread-safe)
				
				// Deque (LinkedList) - Can add/remove from both ends efficiently (also implements List)
				Deque<Character> charactersDeque = new LinkedList<>();
				charactersDeque.addLast('A');
				charactersDeque.addFirst('B');
				charactersDeque.addLast('C');

				System.out.println("Characters Deque (LinkedList): " + charactersDeque); // [B, A, C]
				


				// Set (HashSet) - Unique elements, no order
				Set<String> fruitsSet = new HashSet<>();
				fruitsSet.add("Apple");
				fruitsSet.add("Banana");
				fruitsSet.add("Orange");
				//fruitsSet.add("Orange"); // Duplicate won't be added

				System.out.println("Fruits Set (HashSet): " + fruitsSet); // [Apple, Banana, Orange] (order may vary)
				
				// Set (LinkedHashSet) - Remembers insertion order while maintaining uniqueness
				Set<String> fruitsSet = new LinkedHashSet<>();
				fruitsSet.add("Apple");
				fruitsSet.add("Banana");
				fruitsSet.add("Orange");
				fruitsSet.add("Orange"); // Duplicate won't be added

				System.out.println("Fruits Set (LinkedHashSet): " + fruitsSet); // [Apple, Banana, Orange] (maintains insertion order)

				// Set (TreeSet) - Sorted set based on natural ordering or comparator
				Set<Integer> numbersSet = new TreeSet<>();
				numbersSet.add(10);
				numbersSet.add(5);
				numbersSet.add(15);
				numbersSet.add(5); // Duplicates won't be added (as it's a Set)
				
				System.out.println("Numbers Set (TreeSet): " + numbersSet); // [5, 10, 15] (sorted in ascending order)



				// Map (HashMap) - Key-value pairs, unique keys
				Map<String, Integer> studentGrades = new HashMap<>();
				studentGrades.put("Alice", 90);
				studentGrades.put("Bob", 85);
				studentGrades.put("Charlie", 95); // Overwrites existing key "Charlie"

				System.out.println("Student Grades (HashMap): " + studentGrades); // {Alice=90, Bob=85, Charlie=95}
				
				// Map (LinkedHashMap) - Maintains insertion order for key-value pairs
				Map<String, String> countriesMap = new LinkedHashMap<>();
				countriesMap.put("India", "New Delhi");
				countriesMap.put("China", "Beijing");
				countriesMap.put("Brazil", "Brasilia");

				System.out.println("Countries Map (LinkedHashMap): " + countriesMap); // {India=New Delhi, China=Beijing, Brazil=Brasilia} (maintains insertion order)

				// Map (TreeMap) - Sorted map based on natural ordering or comparator for keys
				Map<Integer, String> studentAgesMap = new TreeMap<>();
				studentAgesMap.put(18, "Alice");
				studentAgesMap.put(20, "Bob");
				studentAgesMap.put(19, "Charlie");

				System.out.println("Student Ages Map (TreeMap): " + studentAgesMap); // {18=Alice, 19=Charlie, 20=Bob} (sorted by key in ascending order)

				// Map (ConcurrentHashMap) - Thread-safe implementation of HashMap
				Map<String, Double> employeeSalariesMap = new ConcurrentHashMap<>();
				employeeSalariesMap.put("Alice", 85000.0);
				employeeSalariesMap.put("Bob", 90000.0);
				employeeSalariesMap.put("Charlie", 78000.0);

				System.out.println("Employee Salaries Map (ConcurrentHashMap): " + employeeSalariesMap); // {Alice=85000.0, Bob=90000.0, Charlie=78000.0} (thread-safe)

				// Map (HashTable) - Legacy thread-safe implementation (less efficient than ConcurrentHashMap, use ConcurrentHashMap for new code)
				Map<String, String> coursesMap = new Hashtable<>();
				coursesMap.put("Java", "Introduction to Java Programming");
				coursesMap.put("Python", "Python for Beginners");
				coursesMap.put("C++", "Fundamentals of C++");

				System.out.println("Courses Map (HashTable): " + coursesMap); // {Java=Introduction to Java Programming, Python=Python for Beginners, C++=Fundamentals of C++} (thread-safe, legacy)

				// Map (IdentityHashMap) - Uses object identity for comparisons (reference equality)
				Map<Student, String> studentsMap = new IdentityHashMap<>();
				Student student1 = new Student("Alice", 18);
				Student student2 = new Student("Bob", 20);
				Student student3 = student1; // Same object as student1

				studentsMap.put(student1, "Java");
				studentsMap.put(student2, "Python");
				studentsMap.put(student3, "C++"); // Will overwrite the entry for student1 since they refer to the same object

				System.out.println("Students Map (IdentityHashMap): " + studentsMap); // {Student(name=Alice, age=18)=Java, Student(name=Bob, age=20)=Python} (uses reference equality)

				// Map (EnumMap) - Compact map specifically designed for enum keys
				enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY }

				Map<Day, String> weekdaysMap = new EnumMap<>(Day.class);
				weekdaysMap.put(Day.MONDAY, "Monday Motivation");
				weekdaysMap.put(Day.WEDNESDAY, "Hump Day!");
				weekdaysMap.put(Day.FRIDAY, "TGIF!"); // Only enum values of Day can be used as keys

				System.out.println("Weekdays Map (EnumMap): " + weekdaysMap); // {MONDAY=Monday Motivation, WEDNESDAY=Hump Day!, FRIDAY=TGIF!}
				
			}
		}
		
===========================================================================================
		
		

	Runnable interface :
	--------------------
		In Java, the Runnable interface is a fundamental building block for multithreading. It defines a single abstract method called run() that specifies the code a thread will execute.
		
		The Runnable interface serves as a contract between a class and the Thread class. By implementing Runnable, a class indicates that its objects can be used to represent tasks that can be executed concurrently by separate threads
		
		Runnable has only one abstract method : public abstract void run();
		
		 A class that needs to be used with threads must implement the Runnable interface and provide its own implementation of the run() method. This implementation specifies the specific work the thread will perform.
		 
		public interface Runnable {
		  void run(); //public abstract
		}
		public class MyRunnable implements Runnable {
			@Override
			public void run() {
				// Code to be executed by the thread
				System.out.println("This is from MyRunnable implementing Runnable interface");
				for (int i = 0; i < 5; i++) {
					System.out.println("Running task in MyRunnable: " + i);
					try {
						Thread.sleep(1000); // Simulate some work
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			}
		}
		public class Main {
			public static void main(String[] args) {
				MyRunnable myRunnable = new MyRunnable();
				Thread thread = new Thread(myRunnable); // Create a Thread object with the Runnable implementation
				thread.start(); // Start the thread to begin execution
				System.out.println("This is from the main thread");
			}
		}
		
===========================================================================================	


	Callable Interface :
	--------------------
		The Callable interface in Java is an extension of the Runnable interface that provides more functionality for working with threads. It allows threads to return a result and potentially throw checked exceptions.
		
		. Return Value: 
			Unlike Runnable which has a void return type for its run method, Callable defines a method with a generic return type V.
			
			public V call() throws Exception;
			
		. Checked Exceptions: 
			The run method of Runnable can only throw unchecked exceptions (RuntimeException and its subclasses). The call method of Callable allows throwing both checked and unchecked exceptions. This provides more flexibility in handling potential errors within the thread.
			
			
		Benefits of Callable :
		. Results: 
			You can retrieve the result of a thread's execution using the Future interface returned by the ExecutorService.submit method. This is useful when you need the output of a thread for further processing in the main thread.
		. Checked Exceptions: 
			By allowing checked exceptions, Callable enables you to handle potential errors that occur within the thread and propagate them back to the main thread for proper handling.

		public interface Callable<V> {
			V call() throws Exception;
		}
		public class FactorialTask implements Callable<Integer> {
			private int number;
			public FactorialTask(int number) {
				this.number = number;
			}
			@Override
			public Integer call() throws Exception {
			if (number < 0) {
				throw new IllegalArgumentException("Number must be non-negative");
			}
			int result = 1;
			for (int i = 1; i <= number; i++) {
			  result *= i;
			}
			return result;
			}
		}
		public class CallableExample implements Callable<Integer> {
			@Override
			public Integer call() throws Exception {
				// Simulate some work and return a result
				int sum = 0;
				for (int i = 1; i <= 10; i++) {
				  sum += i;
				}
				return sum;
			}
		}
		public class Main {
			public static void main(String[] args) throws Exception {
				ExecutorService executor = Executors.newSingleThreadExecutor(); // This line creates an ExecutorService object using the Executors.newSingleThreadExecutor() factory method. This creates a thread pool with a single thread.

				// Submit the Callable task to the ExecutorService
				Future<Integer> future = executor.submit(new CallableExample()); // This line submits the CallableExample object (an instance that represents the task) to the ExecutorService. The submit method returns a Future object which holds the eventual result of the task.

				// Get the result from the Future object (blocks until the thread finishes)
				int result = future.get(); // This line calls the get method on the Future object. This method retrieves the result of the task executed by the CallableExample class. However, this line blocks until the task finishes execution.

				System.out.println("The sum is: " + result); // This line prints the retrieved sum obtained from the CallableExample task.

				executor.shutdown(); // This line shuts down the ExecutorService, indicating that no new tasks will be submitted.
			}
		}
		
		In this example:
		. The CallableExample class implements Callable and overrides the call method.
		. The call method calculates the sum of numbers from 1 to 10 and returns the result.
		. The main method uses an ExecutorService to submit the Callable task.
		. The submit method returns a Future object.
		. The get method of the Future object is used to retrieve the result (the sum) after the thread finishes execution.
		



===========================================================================================

	Future Interface : 
	-----------------
		The Future interface in Java represents the eventual result of an asynchronous computation. It's used in conjunction with the Callable interface to manage tasks that can return results and potentially throw exceptions.
		
		Functionality:
			. Result Placeholder: A Future acts as a placeholder for the result of a task submitted to an ExecutorService.
			. Checking Completion: You can use methods like isDone() to check if the task has finished execution.
			. Cancelling Tasks: Some implementations might support cancelling the task using cancel() before it finishes (depending on the task's nature).
			. Retrieving Results: The get() method allows you to retrieve the result of the task once it's complete. However, get() might block the calling thread until the task finishes.
			
		Key Points:
			. Threads don't directly interact with the Future object. The ExecutorService manages the task execution, and the Future provides a way to interact with the result asynchronously.
			. The get() method can throw exceptions if the task execution throws an exception or if the task is cancelled.
			. Future offers a way to decouple the code that submits a task from the code that retrieves the result, promoting asynchronous programming.
			
		public class FutureExample implements Callable<Integer> {
			@Override
			public Integer call() throws Exception {
				// Simulate some work and return a result
				int sum = 0;
				for (int i = 1; i <= 10; i++) {
					sum += i;
				}
				return sum;
			}
		}
		public class Main {
			public static void main(String[] args) throws Exception {
				ExecutorService executor = Executors.newSingleThreadExecutor();
				// Submit the Callable task to the ExecutorService
				Future<Integer> future = executor.submit(new FutureExample());
				// Check if the task is done (optional)
				if (future.isDone()) {
					System.out.println("Task completed!");
				}
				// Get the result from the Future object (blocks until the thread finishes)
				int result = future.get();
				System.out.println("The sum is: " + result);
				executor.shutdown();
			}
		}


===========================================================================================



Serialization:
--------------
	. Java serialization is the process of converting an object's state into a byte stream so that it can be saved to a file, sent over a network, or stored in a database. 
	. Deserialization is the reverse process where the byte stream is converted back into a copy of the object.
	
	Key Concepts of Serialization
	1. Serializable Interface: 
		. An object must impleme
		nt the java.io.Serializable interface to be serialized. This is a marker interface, meaning it has no methods to implement. It serves to signal the Java Virtual Machine (JVM) that the object is serializable.
		
		
	2. ObjectOutputStream and ObjectInputStream: 
		. ObjectOutputStream is used to write the object to an output stream.
		. ObjectInputStream is used to read the object from an input stream.
		
		
	3. SerialVersionUID:
		. A unique identifier for Serializable classes. It is used during deserialization to ensure that a loaded class is compatible with the serialized object.
		. If no serialVersionUID is explicitly declared, the JVM will generate one at runtime, based on various aspects of the class.	
		
		
	Example --- 
		Step 1: Create a Serializable Class
		-----------------------------------
			@Data
			public class Person implements Serializable {
				private static final long serialVersionUID = 1L;
				
				private String name;
				private int age;
			}
		
		
		Step 2: Serialize the Object
		----------------------------
			public class SerializePerson {
				public static void main(String[] args) throws IOException {
					Person person = new Person("Alice", 30);
					try (FileOutputStream fileOut = new FileOutputStream("person.ser")) { // Create streams for serialization
						ObjectOutputStream out = new ObjectOutputStream(fileOut);
						out.writeObject(person); // Write the object to the stream
						System.out.println("Serialized data is saved in person.ser");
						
						out.close(); // Close the streams
						fileOut.close();
					} catch (IOException i) {
						i.printStackTrace();
					}
					System.out.println("Person object serialized successfully!");
				}
			}

			
			Step 3: Deserialize the Object
			------------------------------
				public class DeserializePerson {
					public static void main(String[] args) throws IOException, ClassNotFoundException {
						Person deserializedPerson = null;
						try (FileInputStream fileIn = new FileInputStream("person.ser")) { // Create streams for deserialization
							ObjectInputStream in = new ObjectInputStream(fileIn);
							deserializedPerson = (Person) in.readObject(); // Read the object from the stream
							
							in.close(); // Close the streams
							fileIn.close();
							
							System.out.println("Deserialized Person:");
							System.out.println("Name: " + deserializedPerson.getName());
							System.out.println("Age: " + deserializedPerson.getAge());
						} catch (IOException i) {
							i.printStackTrace();
						} catch (ClassNotFoundException c) {
							System.out.println("Person class not found");
							c.printStackTrace();
						}
					}
				}
				
				
				
		Additional Considerations : 
		---------------------------
			. Transient Keyword: Fields marked as transient are not serialized.
			
			. Custom Serialization: By defining readObject and writeObject methods, you can customize the serialization process.
			
			. Externalizable Interface: For complete control over serialization, a class can implement the Externalizable interface, which requires implementing writeExternal and readExternal methods.
			
			Example with Transient Field -
			----------------------------
				public class Employee implements Serializable {
					private static final long serialVersionUID = 1L;
					
					private String name;
					private int age;
					private transient String password; // this field will not be serialized
					
					public Employee(String name, int age, String password) {
						this.name = name;
						this.age = age;
						this.password = password;
					}
					
					@Override
					public String toString() {
						return "Employee [name=" + name + ", age=" + age + ", password=" + password + "]";
					}
				}





===========================================================================================




String class : 
--------------
	. In Java String  is a class (not a primitive data type) that represents a sequence of characters.
	. It is immutable, which meaning content can not be modified after creation.
	. java.lang.String class provides methods for manipulating and working with strings.

		String name = "Alice";
		System.out.println(name.length()); // Output: 5


		Strings creation :
		------------------
			. String literal: Using double quotes (" ") creates a String object in the String pool (a memory area for frequently used String values) if it already exists, otherwise a new object is created.
			
				String message = "Hello";

			. new String() constructor: Creates a new String object in heap memory, even if an identical String exists in the pool.
				
				String greeting = new String("Welcome");

		String pool : 
		-------------
			. String pool is a memory area in the JVM that stores String literals created at compile time or using double quotes.
			. When you create a String literal(sequence of characters enclosed within double quotes), the JVM checks the pool. If a matching String exists, it returns the reference to that object, promoting memory efficiency.
			. If no match is found, a new String object is created in the pool.
			
				String str1 = "Hi";
				String str2 = "Hi";

				System.out.println(str1 == str2); // Output: true (both refer to the same object in the String pool)

		compare Strings for equality : 
		------------------------------
			. Use the equals() method of the String class for content-based comparison (case-sensitive).

				String name1 = "Bob";
				String name2 = "bob";

				System.out.println(name1.equals(name2)); // Output: false

			. Use equalsIgnoreCase() for case-insensitive : 
				
				System.out.println(name1.equalsIgnoreCase(name2)); // Output: true
				
			. Never use the == operator for String equality. It checks object references (not content).
			
		Extract substrings from a String : 
		----------------------------------
			. Use the substring(startIndex, endIndex) method to extract a portion of the String.
				
				String fullString = "Java Programming";
				String subString = fullString.substring(5, 15); // "Programming"
				System.out.println(subString);

		 How do you modify the contents of a String : 
			. Since Strings are immutable, you cannot directly change their content. To create a modified version, use methods like concat(), replace(), etc.
				
				String original = "Welcome";
				String modified = original.concat(" Home"); // "Welcome Home" (doesn't change original)
				System.out.println(original); // Still "Welcome"
				System.out.println(modified);
			
			. Consider using mutable String builder classes like StringBuilder or StringBuffer for frequent modifications.

		Search for a character or substring within a String :
			. Use the indexOf(char/String) or lastIndexOf(char/String) methods to find the first or last occurrence, respectively.
				
				String sentence = "Find the word 'word'";
				int firstIndex = sentence.indexOf("word");
				int lastIndex = sentence.lastIndexOf("word");

				System.out.println(firstIndex); // Output: 9
				System.out.println(lastIndex); // Output: 15

		Convert a String to uppercase, lowercase, or another case :
			. Use the toUpperCase() or toLowerCase() methods for case conversion.
				
				String text = "MiXeD CaSe";
				String upperCase = text.toUpperCase();
				String lowerCase = text.toLowerCase();

				System.out.println(upperCase); // Output: MIXED CASE
				System.out.println(lowerCase); // Output: mixed case
				
		Reverse a String : 
			. StringBuilder: Create a StringBuilder object from the String, reverse it using reverse(), and convert it back to String.
				
				String str = "Hello";
				StringBuilder sb = new StringBuilder(str);
				sb.reverse();
				String reversed = sb.toString



===========================================================================================



MULTITHREADING : 
----------------
	Multithreading is a programming concept that allows a program to execute multiple parts concurrently. This creates the illusion that the program is doing multiple things at the same time, but in reality, a single processor is rapidly switching between different tasks (threads). It's beneficial for improving the responsiveness of a program and utilizing the full potential of multi-core processors.

	Threads: 
	--------
		Threads are lightweight units of execution within a process.They share the same memory space and resources of the process. A process can have multiple threads running concurrently.
		It is an instance of "java.lang.Thread"
		
		Thread Lifecycle:
		-----------------
			. New: The thread object is created but not yet started.
			. Runnable: The thread is ready to be run by the scheduler.
			. Running: The thread is currently executing instructions.
			. Waiting/Blocked: The thread is waiting for an event (e.g. I/O operation) to complete before it can continue.
			.Terminated: The thread has finished execution.
		
		Thread Creation :
		-----------------
			1. Extending the Thread class: 
			------------------------------
				This involves creating a subclass of the Thread class and overriding the run method. The run method defines the code that the thread will execute.
				
				// Extending Thread class
				public class MyThread extends Thread {
				  @Override
				  public void run() {
					// Code to be executed by the thread
					System.out.println("This is from MyThread extending Thread class");
				  }
				}
				
			2. Implementing the Runnable interface: 
			---------------------------------------
				This approach involves creating a class that implements the Runnable interface. The Runnable interface has a single abstract method called run. You need to implement the run method to specify the code the thread will execute.
				
				// Implementing Runnable interface
				public class MyRunnable implements Runnable {
				  @Override
				  public void run() {
					// Code to be executed by the thread
					System.out.println("This is from MyRunnable implementing Runnable interface");
				  }
				}



	Processes:
		Processes are heavyweight entities that have their own memory space and resources. They are independent of each other.


	Multithreading Benefits:
	. Improved responsiveness: 
		By executing non-blocking tasks (e.g., waiting for network data) in separate threads, the program remains responsive to user interactions.
	. Efficient resource utilization: 
		Multithreading allows a program to take advantage of multiple cores in a processor, improving overall performance.
	. Background tasks: 
		Long-running tasks can be placed in separate threads to avoid blocking the main thread responsible for the user interface.

	Multithreading Challenges:
	--------------------------
		. Synchronization: 
		------------------
			Synchronization in Java refers to the coordination of access between multiple threads to shared resources.
			It's crucial to prevent data races and inconsistencies when multiple threads are working with the same data.
			
			When multiple threads access shared data, there's a risk of data races and inconsistencies. Synchronization mechanisms like locks and semaphores are needed to ensure proper access and modification of shared data.
			
			
			1. The Problem: Data Races
			Imagine two threads trying to update a bank account balance at the same time. Without synchronization, you might encounter a data race:

			. Thread 1 reads the balance (e.g., $100).
			. Thread 2 reads the same balance ($100).
			. Thread 1 subtracts $50 (but the in-memory value is still $100).
			. Thread 2 subtracts $50 (also from the outdated $100 value).
			. The final balance might incorrectly be $0 instead of the expected $50.
		
			Synchronization Mechanisms:
			---------------------------
				. Synchronized methods() : 
				--------------------------
					Declaring a method as synchronized ensures that only one thread can execute that method at a time. Other threads trying to access the synchronized method will be blocked until the current thread finishes executing it.
				
					public class BankAccount {
					  private int balance;

					  public synchronized void withdraw(int amount) {
						// Synchronized method to ensure safe withdrawal
						balance -= amount;
					  }
					}
				
				. Synchronized blocks{} : 
				-------------------------
					You can use a synchronized block to control access to a specific code section within a method. Only one thread can enter the synchronized block at a time.
					
					public class SynchronizedBlockCounter {
					  private int count;

					  public void increment() {
						synchronized (this) { // Synchronize on the current object
						  count++;
						}
					  }
					}
					
					OR
					
					public class SynchronizedBlockSharedCounter {
					  private int count = 0;
					  public void increment() {
						synchronized (this) { // Synchronize on the current object
						  count++;
						}
					  }
					  public int getCount() {
						return count;
					  }

					  public static void main(String[] args) throws InterruptedException {
						SynchronizedBlockSharedCounter counter = new SynchronizedBlockSharedCounter();
						Thread thread1 = new Thread(() -> {
						  for (int i = 0; i < 10000; i++) {
							counter.increment();
						  }
						});
						Thread thread2 = new Thread(() -> {
						  for (int i = 0; i < 10000; i++) {
							counter.increment();
						  }
						});

						thread1.start();
						thread2.start();

						thread1.join();
						thread2.join();

						System.out.println("Final count: " + counter.getCount()); // Should print 20000
					  }
					}

				static synchronized :
				---------------------
					static synchronization is a specific type of synchronization that applies to class-level locks rather than object-level locks used in regular synchronized methods and blocks.
					
					When a static method of a class accesses shared resources (static or non-static) of that class, static synchronization can be used to ensure only one thread can execute that method at a time. This prevents race conditions and data inconsistencies.
					
					public class StaticSynchronizedMyClass {
					  private static int counter = 0;

					  public static synchronized void incrementCounter() {
						counter++;
					  }
					}
					
					OR
					
					public class StaticSynchronizedPrinter {
					  public static synchronized void printDocument(String document) {
						// Simulate printing process (slow)
						System.out.println("Printing document: " + document);
						try {
						  Thread.sleep(1000);
						} catch (InterruptedException e) {
						  e.printStackTrace();
						}
					  }
					}

					public class Main {
					  public static void main(String[] args) {
						Thread thread1 = new Thread(() -> StaticSynchronizedPrinter.printDocument("Doc 1"));
						Thread thread2 = new Thread(() -> StaticSynchronizedPrinter.printDocument("Doc 2"));

						thread1.start();
						thread2.start();
					  }
					}


				
			
		. Deadlocks: 
			A deadlock occurs when two or more threads are waiting for each other's resources, creating a permanent halt. Careful design and resource management are crucial to avoid deadlocks.
		. Complexity: 
			Multithreaded code can be more complex to write and debug compared to single-threaded code.


		Java Multithreading Example:
		----------------------------
			public class MultithreadingExample {
				public static void main(String[] args) {
					
					// Thread 1 to print even numbers
					Thread evenThread = new Thread(() -> {
						for (int i = 0; i <= 10; i += 2) {
							System.out.println(i);
						}
					});

					// Thread 2 to print odd numbers
					Thread oddThread = new Thread(() -> {
						for (int i = 1; i <= 9; i += 2) {
							System.out.println(i);
						}
					});

					// Start the threads
					evenThread.start();
					oddThread.start();
				}
			}



	final : 
	-------
		final keyword is an access modifier which used to apply restrictions on class, methods, and variables.

		. final classs can not be inherited.
		. final method can not be overridded.
		. final variable value can not be changed.


	finally{} Block: 
	----------------
		The finally{} block is an optional block that always executes, regardless of whether an exception occurs or not. It's typically used to release resources (e.g., closing files, database connections) that were acquired within the try block. The finally block ensures that these resources are properly cleaned up even if an exception disrupts the normal program flow.
		
		
		You cannot use a finally block by itself without a try block. The finally block relies on the try block to define the code segment it needs to execute after.

		try(){}...catch(){}...catch(){}...finally{}
		try(){}...catch(){}...finally{}
		try(){}...finally{}


		Notes : 
		. You cannot have multiple try blocks with a single catch. catch creates ambiguity about which exception the catch block should handle

		. some alternative approaches: 
			Nested Try-Catch Blocks
			Multiple Catch Blocks
			Separate Try-Catch Blocks

		
	finalize() method :
	------------------- 
		finalize method in Java is a garbage collection mechanism that allows objects to perform some cleanup tasks before they are removed from memory.
		
		. Non-deterministic: 
			There's no guarantee exactly when the finalize method will be called. It might be called immediately after the object becomes eligible for garbage collection, or it might be delayed until much later. You should not rely on finalize to perform critical cleanup tasks that must happen before the object is garbage collected.
		. Protected method: 
			The finalize method is declared as protected in the Object class, meaning it can be directly invoked only by subclasses or from within the same package.
		. No arguments and no return value: 
			The finalize method takes no arguments and doesn't return any value.
			
			
		ex - 
		class Resource {
			private boolean isReleased = false;
			
			public void close() {
				// Simulate releasing a resource (e.g., closing a file)
				System.out.println("Resource released.");
				isReleased = true;
			}

			@Override
			protected void finalize() throws Throwable {
				if (!isReleased) {
				  System.out.println("Resource was not released properly! Performing forced cleanup in finalize...");
				  close();
				}
				super.finalize(); // Call finalize method of parent class (Object)
			  }
			}

			public class Main {
			  public static void main(String[] args) {
				Resource resource = new Resource();
				// ... use the resource

				// Forget to close the resource explicitly
			}
		
		
		Explanation:

		. The Resource class has a close method that simulates releasing a resource.
		. The finalize method checks if the resource is released (isReleased flag).
		. If not released, it prints a message and calls the close method to perform the cleanup.
		. The finalize method also calls super.finalize() to ensure proper finalization of the parent class (Object).
		
		
		Problems with finalize():

		. Unreliable timing: 
			As mentioned earlier, the timing of finalize is unpredictable. You cannot rely on it to happen at a specific time.
		. Not guaranteed to be called: 
			In some cases, the garbage collector might not call finalize at all, especially if the object is unreachable and there's no memory pressure.
		. Potential performance overhead: 
			Finalization adds some overhead to the garbage collection process.
		. Exceptions in finalize can cause problems: 
			If an exception occurs within the finalize method, it's ignored and the garbage collection process continues. This can lead to unexpected behavior or resource leaks.
			
			
		Alternatives to finalize:

		. Use   statement: 
			This is the preferred way to manage resources in Java 7 and later. It ensures that the resource's close method is called automatically when the resource is no longer needed, even if an exception occurs.
		. Utilize dependency injection: 
			By injecting resources through constructors or dependency injection frameworks, you can ensure that the resources are properly managed by the container or framework itself.

===========================================================================================




JAVA EXCEPTION HANDELING : 
--------------------------

	Throwable : 
	. The Throwable class in Java is the root of exceptions and errors in the Java language. 
	. All exception and error classes in Java (including Exception, RuntimeException, Error, etc.) directly or indirectly inherit from Throwable.

	. When an exception occurs, a Throwable object is created and thrown. This object encapsulates information about the error, such as the type of exception, its message, and the call stack (trace of method calls leading to the exception).

	. Methods : Throwable provides several useful methods for handling exceptions:
		. getMessage() : 
			Returns the detail message associated with the exception (if any).
		. printStackTrace() : 
			Prints the stack trace of the exception to the standard error output stream. This is helpful for debugging purposes.
		. getCause() : 
			Returns the cause of this throwable (if any). This allows for chaining exceptions, where one exception can be caused by another.
		. getStackTrace() : 
			Returns an array of StackTraceElement objects representing the call stack at the time the exception was thrown.
		
	public class DivisionByZero {
		public static void main(String[] args) {
			try {
				int result = 10 / 0; // This line will throw an ArithmeticException
				System.out.println(result);
			} catch (Throwable t) {
				System.out.println("An error occurred:");
				// Get the type of exception
				System.out.println("Exception type: " + t.getClass().getName());
				// Get the error message (if any)
				System.out.println("Error message: " + t.getMessage());
				// Print the stack trace for debugging
				t.printStackTrace();
			}
		}
	}
	
	Output:
	An error occurred:
	Exception type: java.lang.ArithmeticException
	Error message: / by zero
	java.lang.ArithmeticException: / by zero
    at DivisionByZero.main(DivisionByZero.java:7)
	
	. Using Throwable directly in catch blocks is generally not recommended unless you intend to handle all possible exceptions in the same way.



	Error : 
	. Error is a subclass of Throwable that represents serious problems that are typically not recoverable within an application. These errors often indicate environmental or system issues that are beyond the program's control.
	
	. Errors are intended for exceptional situations that should not occur under normal program execution. They signal severe resource issues, virtual machine malfunctions, or other critical problems.
	
	. Unlike checked exceptions, catching Error is not mandatory in a try-catch block. The Java compiler doesn't require you to declare throws Error in method signatures, as these errors are not anticipated.
	
	.Recovering from an Error is generally difficult or impossible within the application itself. Often, these errors require program termination or system intervention.
	
	. Subclasses of Error : 
		. OutOfMemoryError, 
		. StackOverflowError, and 
		. VirtualMachineError. 
		
	public class OutOfMemoryErrorExample {

		public static void main(String[] args) {
			try {
				// Code that intentionally allocates a massive amount of memory,
				// potentially causing an OutOfMemoryError
				byte[] largeArray = new byte[Integer.MAX_VALUE];
			} catch (Error e) { // Not recommended to catch Error directly
				System.out.println("A critical error occurred:");
				System.out.println("Error type: " + e.getClass().getName());
				System.out.println("Error message: " + e.getMessage());
				// Consider logging the error or gracefully terminating the program
			}
		}
	}
	
	. Catching Error is generally not advisable. It's better to design your application to avoid situations that might lead to these errors or implement robust error handling mechanisms for specific Error subclasses if necessary.



	Exception :
	-----------
		. Exceptions are events that disrupt the normal flow of program execution. They represent unexpected conditions that occur during runtime.
		. When an exception occurs, an exception object is created and thrown. This object contains information about the error, including the type of exception and its message.

		Type of Exception :
		1. Checked Exceptions: 
			These exceptions are compiled-time errors. The Java compiler requires you to either declare that a method throws a checked exception or handle it within the method itself using a try-catch block. Examples include IOException (for file input/output issues) and ClassNotFoundException (when a class cannot be found).

		2. Unchecked Exceptions: 
			These exceptions are runtime errors. The Java compiler doesn't force you to handle them, but it's generally good practice to do so for robust applications. Unchecked exceptions typically represent programming errors or unexpected conditions that can be handled gracefully (e.g., NullPointerException, IndexOutOfBoundsException).
			
		

	Exception Handling Mechanisms : 
	1. try-catch Block: 
		This is the most common way to handle exceptions. It consists of a try block that contains the code you want to monitor for exceptions, followed by one or more catch blocks that specify the type of exception to handle and the code to execute if that exception occurs.
		
		try {
			int result = 10 / 0; // This line will throw an ArithmeticException
			System.out.println(result);
		} catch (ArithmeticException e) {
			System.out.println("Division by zero error occurred!");
		}


	2. throws Keyword: 
		This keyword is used within a method declaration to indicate that the method might throw a specific exception (or exceptions). It helps callers understand the potential exceptions that could arise when calling the method and allows them to handle them appropriately.
		
		public void readFile(String filename) throws IOException {
			// Code that reads a file
		}


	3. finally{} Block: 
		The finally{} block is an optional block that always executes, regardless of whether an exception occurs or not. It's typically used to release resources (e.g., closing files, database connections) that were acquired within the try block. The finally block ensures that these resources are properly cleaned up even if an exception disrupts the normal program flow.
		
		
		You cannot use a finally block by itself without a try block. The finally block relies on the try block to define the code segment it needs to execute after.

		try(){}...catch(){}...catch(){}...finally{}
		try(){}...catch(){}...finally{}
		try(){}...finally{}


		Notes : 
		. You cannot have multiple try blocks with a single catch.catch creates ambiguity about which exception the catch block should handle

		. some alternative approaches: 
			. Nested Try-Catch Blocks
			. Multiple Catch Blocks
			. Separate Try-Catch Blocks
		
		
		try (Scanner scanner = new Scanner(new File("data.txt"))) {
			// Code that reads data from the file
		} catch (FileNotFoundException e) {
			System.out.println("File not found!");
		} finally {
			// Scanner object will be automatically closed here
		}

		
		Benefits of Exception Handling : 

		. Robustness: 
			By handling exceptions gracefully, you can prevent your program from crashing unexpectedly and make it more resilient to unexpected errors.
		. Maintainability: 
			Exception handling improves the code's readability and maintainability by separating normal program flow from error handling logic.
		. Informative Error Messages: 
			You can provide informative error messages to users when exceptions occur, helping them understand the issue and possibly take corrective actions.

===========================================================================================	

	
	

JAVA 8 : 
--------
	Java 8 marked a significant step forward for the Java language, introducing several powerful features that improved code readability, conciseness, and functional programming capabilities

	1. Lambda Expressions:
		. Lambda expressions provide a concise way to define anonymous functions. They eliminate the need for bulky anonymous inner classes, making code more compact and readable.
		. Syntax: (parameters) -> { body }
		
		Example -- 

		// Using lambda expression
		Comparator<Integer> comparator = (a, b) -> a - b;
		
		// Traditional anonymous inner class
		Comparator<Integer> comparator = new Comparator<Integer>() {
			@Override
			public int compare(Integer o1, Integer o2) {
				return o1 - o2;
			}
		};
		
		
	2. Functional Interfaces:
		. Functional interface is an interface that contains exactly one abstract method. They are also known as Single Abstract Method (SAM) interfaces.

		. Optional default and static methods: 
			. It can have any number of default and static methods. These methods provide default implementations or utility functions that can be reused across implementations.

		. @FunctionalInterface annotation is not mandatory but recommended for functional interfaces. It improves code clarity.
		
		. Java 8 introduced several built-in functional interfaces like Function (for functions that map one value to another), Predicate (for boolean-valued functions), Consumer (for functions that consume an argument), etc.
		
	
	3. Stream API:
		. The Stream API offers a powerful way to process collections of data in a declarative and functional style. It allows you to perform operations like filtering, mapping, and reducing on streams of elements without explicit loops.
		. Streams are lazy, meaning operations are not executed until a terminal operation (e.g., count, collect) is called.
		
		Example -- 
		List<String> names = Arrays.asList("John", "Alice", "Bob");

		// Filter names starting with A
		List<String> filteredNames = names.stream()
										 .filter(name -> name.startsWith("A"))
										 .collect(Collectors.toList());

		System.out.println(filteredNames); // Output: [Alice]
		
		
		Java Streams follow a three-phased approach to process data:

			1. Split: This phase involves creating the stream itself. You typically use a collection, an array, or a generator function as the data source. This source is then converted into a Stream object.

			2. Apply: In this phase, you chain one or more intermediate operations onto the stream. These operations are lazily evaluated, meaning they are not executed until a terminal operation is called. Examples of intermediate operations include filter, map, and sorted.

			3. Combine: Finally, you call a terminal operation on the stream. This terminal operation triggers the actual processing of the stream elements according to the specified logic. Terminal operations include forEach, collect, and count.


	4. Default and Static Methods in Interfaces:
		. Java 8 allows adding default and static methods to interfaces.
		. Default methods provide a way to define default implementations for interface methods, enabling backward compatibility with existing code.
		. Static methods can be used to define utility methods that don't require an object instance of the interface.
		
		@FunctionalInterface
		public interface Shape {
			double calculateArea(); // Abstract method - needs implementation in implementing class

			default void printInfo() { // Default method with implementation
				System.out.println("This is a shape object.");
			}

			static double calculateTotalArea(Shape[] shapes) { // Static method - can be called directly using interface name
				double totalArea = 0;
				for (Shape shape : shapes) {
					totalArea += shape.calculateArea();
				}
				return totalArea;
			}
		}
		public class Circle implements Shape {
			private double radius;
			
			public Circle(double radius) {
				this.radius = radius;
			}

			@Override
			public double calculateArea() {
				return Math.PI * radius * radius;
			}

			// Can override the default method if needed
			@Override
			public void printInfo() {
				System.out.println("This is a circle object with radius: " + radius);
			}
		}
		public class Main {
			public static void main(String[] args) {
				Circle circle1 = new Circle(5);
				Circle circle2 = new Circle(3);

				System.out.println("Circle 1 Area: " + circle1.calculateArea()); // Calling abstract method through object

				circle1.printInfo(); // Calling default method through object (can be overridden)

				System.out.println("Total Area of both circles: " + Shape.calculateTotalArea(new Shape[]{circle1, circle2})); // Calling static method directly using interface name
			}
		}


	5. Optional Class:
		The Optional class helps deal with null references in a safer and more elegant way. It provides methods to check for nullity, extract values if present, or provide alternative values in case of null.
		
		Example -- 
		// Traditional null check
		String name = getCustomer().getName();  // Could be null
		if (name != null) {
			System.out.println("Customer name: " + name);
		}

		// Using Optional
		Optional<String> optionalName = Optional.ofNullable(getCustomer().getName());
		optionalName.ifPresent(name -> System.out.println("Customer name: " + name));
		
		//using Stream api and Optional class and Lambda expression togather
		getCustomer().stream()
           .filter(Optional::isPresent) // Filter for non-null values using Optional::isPresent
           .map(Optional::get)        // Extract the value from the Optional
           .forEach(name -> System.out.println("Customer name: " + name)); // lambda expression

		
		//using method references
		getCustomer().getName().ifPresent(System.out::println);



	6. Date and Time API:
		. Java 8 introduced a revamped Date and Time API that's more intuitive and easier to use than the legacy java.util.Date class.
		. It provides classes like LocalDate, LocalTime, and LocalDateTime for representing dates, times, and date-times, along with methods for manipulating and formatting them.
		
		Example -- 
		LocalDate today = LocalDate.now();
		System.out.println("Today's date: " + today);

		LocalTime currentTime = LocalTime.now();
		System.out.println("Current time: " + currentTime);


	7. Method References:
		Method references provide a concise way to refer to existing methods without explicitly defining a lambda expression. They can be used for methods in classes or instances.
	
		Example --
		List<String> names = Arrays.asList("John", "Alice", "Bob");

		// Using lambda expression
		names.sort((a, b) -> a.compareTo(b));

		// Using method reference
		names.sort(String::compareTo);
		
		

===========================================================================================



Stack Memory : 
	. Purpose: The stack is a Last-In-First-Out (LIFO) data structure. Imagine a stack of plates: you add plates on top (push), and remove them from the top (pop). Similarly, the stack is used to manage method calls, local variables, and function parameters.
	. Allocation: Stack memory is allocated statically at compile time. The size of the stack is predefined for a program's execution and is typically limited.
	. Management: Stack management is automatic. The operating system handles allocation and deallocation as methods are called and return.
	. Content: The stack stores temporary data specific to a function's execution, such as:
		. Local variables: Variables declared within a function.
		. Function parameters: Arguments passed to a function.
		. Return addresses: Information about where to return after a function call.
		
		public void doSomething(int x, String message) {
			int y = x * 2;  // Local variable
			System.out.println(message);  // Function parameter
		}

		// When doSomething() is called:
		// - x, y, and message are pushed onto the stack.
		// - doSomething() executes.
		// - After execution, x, y, and message are popped from the stack,
		//   freeing up memory for the next function call.


Heap Memory : 
	. Purpose: The heap is a dynamic memory allocation area. It's like a large, unordered pool of memory that programs can request and release as needed.
	. Allocation: Heap memory is allocated dynamically at runtime using the new keyword (in Java) or similar mechanisms in other languages. The program explicitly requests memory, and the system allocates it from the available heap space.
	. Management: Unlike the stack, the heap requires manual management. Programmers are responsible for freeing memory using techniques like garbage collection (automatic memory reclaim) or delete (manual deallocation) to prevent memory leaks.
	. Content: The heap stores objects created at runtime, such as:
		. Objects instantiated with new: String, Integer, custom classes, etc.
		. Arrays created with new: int[], String[], etc.
		
		public class Person {
			String name;
			int age;

			public Person(String name, int age) {
			this.name = name;
			this.age = age;
			}
		}

		Person john = new Person("John", 30);  // john is allocated in the heap

		// Later, when john is no longer needed:
		john = null;  // Reference is set to null, potentially triggering garbage collection



===========================================================================================


Reading and Writing Files : 
------------------------------

. The InputStream is used to read data from a source and 
. The OutputStream is used for writing data to a destination.

The two important streams are -- 
1. FileInputStream and 
2. FileOutputStream.

FileInputStream:
---------------
	Following constructor takes a file name as a string to create an input stream object to read the file −

		InputStream is = new FileInputStream("C:/java/hello");
	

	Following constructor takes a file object to create an input stream object to read the file. First we create a file object using File() method as follows −
	
		File f = new File("C:/java/hello");
		InputStream is = new FileInputStream(f);
	
	
	meethods used for FileInputStream --
		1. public void close() throws IOException{}
		2. public void finalize() throws IOException{}
		3. public int read(int r) throws IOException{}
		4. public int read(byte[] r) throws IOException{}
		5. public int available() throws IOException{}
		

FileOutputStream:
----------------
	FileOutputStream is used to create a file and write data into it. The stream would create a file, if it doesn't already exist, before opening it for output.

	Following constructor takes a file name as a string to create an input stream object to write the file −

		OutputStream os = new FileOutputStream("C:/java/hello") ;
	
	
	Following constructor takes a file object to create an output stream object to write the file. First, we create a file object using File() method as follows −

		File f = new File("C:/java/hello");
		OutputStream os = new FileOutputStream(f);
	
	meethods used for FileInputStream --
		1.public void close() throws IOException{}
		2.protected void finalize()throws IOException {}
		3.public void write(int w)throws IOException{}
		4.public void write(byte[] w)
		
		
	Example --
	Following is the example to demonstrate InputStream and OutputStream −

	import java.io.*;
	
	public class Main {
		public static void main(String[] args) {
		
			File myFile = new File("D:\\ABC.txt");
			if (myFile.exists()) {
				System.out.println(myFile.getName() + " exists");
				System.out.println("The file is " + myFile.length() + " bytes long");
				
				if (myFile.canRead())
					System.out.println(" ok to read");
				else
					System.out.println(" not ok to read");
					
				if (myFile.canWrite())
					System.out.println(" ok to write");
				else
					System.out.println(" not ok to write");
					
				System.out.println("path: " +myFile.getAbsolutePath());
				System.out.println("File Name: "+ myFile.getName());
				System.out.println("File Size: "+ myFile.length() + " bytes");
			} else
				System.out.println("File does not exist");
			
			try {    
				// FileOutputStream fout=new FileOutputStream("D:\\testout.txt"); 
				OutputStream fos=new FileOutputStream(myFile);
				String s="XYZ";    
				byte b[]=s.getBytes();
				fos.write(b);
				
				fos.close();    
				System.out.println("success..."); 
				
				//FileInputStream fin=new FileInputStream("D:\\testout.txt");    
				InputStream fis=new FileInputStream(myFile);    
				int i=0;     
				while((i=fis.read())!=-1){    
					System.out.print((char)i);    
				}     

				fis.close();
				
			}catch(Exception e){
				System.out.println(e);
			} 
			
		}
	}
	
===========================================================================================
	
	
	
	
	
	
JDBC : Java database connectivity
------
	It is standard API provides by Oracle for java applications to interact with different set of database.

	JavaApp ---> JDBC ---> DataBase

	Architecture of JDBC :
	-----------------------

	Java app <--> JDBC api  <==> JDBC Database Driver <--> Database


	JDBC API :
	-----------
	Important Classes and Interfaces
	java.sql.DriverManager
	java.sql.Statement
	java.sql.PreparedStatement
	java.sql.CallableStatement
	java.sql.ResultSet
	java.sql.ResultSetMetaData
	java.sql.DataBaseMetaData
	java.sql.SQLException


	Set JDBC Driver (mysql-connector.jar) files in your classpath :
	---------------------------------------------------------------
	http://www.java2s.com/Code/Jar/m/Downloadmysqlconnectorjar.htm
	classpath --> C:\mysql-connector.jar
	cmd --> javap com.mysql.jdbc.Driver


	Connection with Database :
	--------------------------

	1. Load the driver :
		Class.forName("com.mysql.cj.jdbc.Driver"); // in try-catch to handle sql exception.
			or
		DriverManager.registerDriver(new com.mysql.cj.jdbc.Driver());
		
	2. Create Connection :
		Connection con=DriverManager.getConnection("url","username","password");
		ie.
		Connection con=DriverManager.getConnection("jdbc:mysql://localhost:3306/dbname","root","root");

	3. Create query,Statement,/PreparedStatement,/CollableStatement
		eg
			String q="select * from students";
			
			Statement stmt=con.createStament();
			
			// stmt.executUpdate();//for insert,update,delete //return type is int 
			// stmt.execute();//for insert,update,delete  
			ResultSet rs=stmt.executeQuery(q);//for select  //return type is resultSet and we get data in resultSet.
			
	4. Process the Data :
		while(rs.next()){
			int id=rs.getInt("studentId");
			String name=rs.getString("studentName");
			System.out.println(id);
			System.out.println(name);
		}
		
	5. Close the connection :
		con.close();
		
		
		
	OR
	
	application.properties : 
		server.port = 8081

		spring.application.name=crudwithdao

		spring.datasource.username=root
		spring.datasource.password=root
		spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
		spring.datasource.url=jdbc:mysql://localhost:3306/crudwithdao?createDatabaseIfNotExist=true 

		spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
		spring.jpa.generate-ddl=true
		spring.jpa.hibernate.ddl-auto=update
		spring.jpa.show-sql=true
			
		
===========================================================================================


Singleton class :
-----------------
	Class in which we can create only one OBJECT but it can be shared.


	Understand this with the help of an example-:
	---------------------------------------------
	Consider the water jug in the office and if every employee wants that water then they will not create a new water jug for drinking water.They will use the existing one with their own reference as a glass. So programmatically it should be implemented as -

	class WaterJug{
		private int waterQuantity = 500; // private variable
		private WaterJug(){} // 1. private default constructor

		private static volatile WaterJug object = null; // 2. static volatile object initialized to null.

		public int getWater(int quantity){ // Method to provide the service of Giving Water.
		   waterQuantity -= quantity;
		   return quantity;
		}
	   
		public static Waterjug instance(){ // 3. Static method which return WaterJug object.
			if(object == null){ // 4. Create a new object if the object is not already created and return the object.
				synchronized(Employee.class){ // 5. Double Checked locking Pattern : checking null condition above and below synchronized method.
					if(object == null){ // 6. Create a new object if the object is not already created and return the object.
						object = new WaterJug();
					}
				}
			}
			return object;
	   }
	}
	

	In the above class, the Constructor is private so we cannot create the object of the class. But we can get the object by calling the method getInstance(). 
	And the getInstance is static so it can be called without creating the object. And it returns the object. 
	Now with that object, we can call getWater() to get the water.

	Waterjug glass1 = WaterJug.getInstance();
	glass1.getWater(1);
	We can get the single object using this getInstance(). And it is static, so it is a thread-safe singleton class. 
	Although there are many ways to create a thread-safe singleton class. So thread-safe classes can also be:

	When singletons are written with double-checked locking, they can be thread-safe.
	We can use static singletons that are initialized during class loading. Like we did in the above example. 
	Above example can be broken using reflection.
	
	But the most straightforward way to create a thread-safe singleton is to use Java enums.
	
	public enumEnumSingleton{
		INSTANCE;
		public static void doSomething(){
			//println/ do something
		}
	}


===========================================================================================


Hibernet :
-----------
	* Hibernate is a java framework that simplifies the development of java application
		to interact with database.
	* Hibernate is ORM(Object Relation Mapping) tool.

	* Hibernate is open source, lightweight.

	* Hibernate is a loosely coupled framework, means it wont forces the programmer 
		to extend/implement any class/interface.
		
	* Any type of application can build with Hibernate Framework.


			class --> Object(Data) --> Hibernate Framework <--> DB(Data)
			

	Core Functionalities:

	. Object-Relational Mapping: 
		Maps Java classes and their properties to database tables and columns, respectively. This eliminates the need for writing complex SQL queries directly, improving developer productivity.
	. Automatic SQL Generation: 
		Based on your object definitions, Hibernate automatically generates efficient SQL queries for data persistence (INSERT, UPDATE, DELETE), retrieval (SELECT), and other database operations.
	. Caching: 
		Stores frequently accessed data in memory for faster retrieval, enhancing application performance.
	. Transaction Management: 
		Handles database transactions (commit, rollback) automatically, ensuring data consistency and integrity.
	. Query Language (HQL): 
		Provides a high-level, object-oriented query language (Hibernate Query Language) that resembles SQL but operates on objects, reducing the need for writing raw SQL and promoting database independence (queries can work with different databases).
		
		
	Benefits of Using Hibernate:

	. Increased Productivity: 
		Less time is spent writing and maintaining complex SQL queries, allowing developers to focus on application logic.
	. Improved Maintainability: 
		Object-oriented data access code is easier to understand and maintain than raw SQL, especially for complex data models.
	. Database Independence: 
		Hibernate handles mapping between objects and tables, making applications less dependent on the underlying database schema. Changes to the database schema can often be accommodated with minimal code modifications in Hibernate mappings.
	. Transaction Management: 
		Automatic transaction handling ensures data consistency and reduces the risk of errors.
	. Caching: 
		Improved performance by caching frequently accessed data in memory.
		
		
	Additional Considerations:

	. Hibernate supports various mapping annotations (e.g., @Entity, @Id, @Column) to further define object-to-table relationships and property-to-column mappings.
	. Hibernate offers advanced features like lazy loading, eager fetching, criteria queries, and more to optimize data retrieval and manipulation.
	
	
	Example Code:
	
	1. Product Class:
	
		@Entity
		public class Product {
			@Id
			@Column
			private Long id;
			private String name;
			private Double price;

			// Getters and setters omitted for brevity
		}
		
	
	2. Hibernate Configuration (hibernate.cfg.xml):
	
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE hibernate-configuration PUBLIC
				"-//Hibernate/Hibernate Configuration DTD 3.0//EN"
				"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
		<hibernate-configuration>
			<session-factory>
				<property name="connection.driver_class">org.h2.Driver</property>
				<property name="connection.url">jdbc:h2:mem:testdb</property>
				<property name="connection.username">sa</property>
				<property name="connection.password"></property>
				<property name="hibernate.dialect">org.hibernate.dialect.H2Dialect</property>
				<mapping class="com.example.Product" />  </session-factory>
		</hibernate-configuration>
		
		
	3. Saving a Product Object:
			
		Product product = new Product();
		product.setName("T-Shirt");
		product.setPrice(24.99);

		SessionFactory sessionFactory = // Create a Hibernate session factory
		Session session = sessionFactory.openSession();

		session.beginTransaction();
		session.save(product);  // Save the Product object
		session.getTransaction().commit();

		session.close();


	Hibernate persistance lifecycle state :
	1. Transient state
		When we create object and set value using getter/setter or constructor then objects goes into transient state.
		Transient state object data does not go in DB or session object.
		
	2. Persistance state
		When we save or update or persist transient object using session it goes into Persistent state.
		Persistance state object data goes into session object and DB also.
		If we make any changes in persistent state object the changes will reflect in DB and session object both.

	3. Detached state
		When we close or clear Persistent state object it goes into Detached state.
		Detached state object data goes into DB only but did not goes into session object.
		Ater updating Detached state using session it again goes into Persistent state.
		
	4. Removed state
		When we delete Persistent state object it goes only in session object and did not go into DB.


	example --
		public class Product {
			@Id
			private Long id;
			private String name;
			private Double price;
			// Getters and setters omitted for brevity
		}

		public static void main(String[] args) {
			SessionFactory sessionFactory = // Create a Hibernate session factory
			Session session = sessionFactory.openSession();

			// Transient state
			Product product = new Product();
			product.setName("T-Shirt");
			product.setPrice(24.99);

			// Save the product (Transient -> Persistent)
			session.beginTransaction();
			session.save(product);
			session.getTransaction().commit();

			// Now product is in the Persistent state

			// Detach the product (Persistent -> Detached)
			session.detach(product);

			// Modifications to product in detached state won't be reflected in the database

			// Reattach the product to a new session (Detached -> Persistent)
			session = sessionFactory.openSession();
			session.beginTransaction();
			session.attach(product);

			// Update the product's price (Persistent)
			product.setPrice(19.99);

			// Commit the transaction (updates are flushed to the database)
			session.getTransaction().commit();

			// Delete the product (Persistent -> Removed)
			session.delete(product);
			session.getTransaction().commit();

			session.close();
		}



===========================================================================================






===========================================================================================

Java access modifiers : 
-----------------------

1. public
	Access Level: Can be accessed from any other class.
	Usage: When you want to allow access to the member (variable, method, or class) from any other code, regardless of its package.

2. protected
	Access Level: Can be accessed within the same package and by subclasses in other packages.
	Usage: When you want to allow access within the package and also allow inheritance-related access from subclasses.
	
3. default (no modifier)
	Access Level: Can be accessed only within the same package. It is also known as package-private access.
	Usage: When you want to restrict access to within the same package but do not want to make it explicitly protected or public.
	
4. private
	Access Level: Can be accessed only within the same class.
	Usage: When you want to restrict access to the member strictly to within the class itself, providing encapsulation.



===========================================================================================

1. JVM (Java Virtual Machine)
	Definition: The JVM is a virtual machine that enables a computer to run Java programs. It converts Java bytecode into machine code that can be executed by the host operating system.
	
	. Role:
		. Execution: It is responsible for running Java applications. When you run a Java program, the JVM interprets or compiles the bytecode into machine code.
		. Memory Management: Manages the memory allocation and garbage collection.
		. Platform Independence: Allows Java programs to be run on any device or operating system that has a JVM implementation, making Java programs "write once, run anywhere" (WORA).
	. Components:
		. Class Loader: Loads class files.
		. Bytecode Verifier: Checks the code fragments for illegal code that can violate access rights.
		. Interpreter: Converts bytecode into native machine code.
		. Just-In-Time (JIT) Compiler: Improves performance by compiling bytecode into native code at runtime.
	
2. JDK (Java Development Kit)
	Definition: The JDK is a software development kit used to develop Java applications. It includes the JRE, an interpreter/loader (Java), a compiler (javac), an archiver (jar), a documentation generator (Javadoc), and other tools needed for Java development.
	
	Role:
	. Development: Provides tools to compile, debug, and execute Java applications.
	. Components:
		. JRE: The runtime environment needed to run Java applications.
		. Development Tools: Includes javac (compiler), jar (archiver), javadoc (documentation generator), and other tools for development.
	
3. JRE (Java Runtime Environment)
	Definition: The JRE is a part of the JDK that provides the libraries, Java Virtual Machine (JVM), and other components to run applications written in Java.
	
	Role:
	. Runtime Environment: It provides the necessary environment for running Java applications.
	. Components:
		. JVM: To run the Java bytecode.
		. Libraries: Standard class libraries that provide common functionalities (e.g., collections, I/O, networking).


JDK
├── JRE
│   ├── JVM
│   └── Libraries
└── Development Tools
    ├── Compiler (javac)
    ├── Archiver (jar)
    ├── Documentation Generator (javadoc)
    └── Other tools


Summary
	. JVM: Runs Java bytecode and enables platform independence.
	. JDK: Provides tools to develop Java applications, including the JRE.
	. JRE: Provides the necessary libraries and JVM to run Java applications.

===========================================================================================







===========================================================================================


MYSQL : 
-------
	MySQL is a freely available, open-source relational database management system (RDBMS) that uses the Structured Query Language (SQL) for data manipulation. It's popular for its speed, reliability, and ease of use, making it a great choice for web applications and various other projects.
	
		SQL Query:
			SELECT product_name FROM products WHERE product_id = 10;

		HQL Query:
			SessionFactory sessionFactory = configuration.buildSessionFactory();
			Session session = null;
			String retrievedName = null;
			try {
				session = sessionFactory.openSession();
				// Your code from the prompt using the session object
				String query = "SELECT p.name FROM Product p WHERE p.id = :productId";
				Query hibernateQuery = session.createQuery(query);
				hibernateQuery.setParameter("productId", 10); // Set the parameter value
				List<String> productNames = (List<String>) hibernateQuery.list();
				retrievedName = productNames.get(0); // Access the first product name (assuming there's a result)
			} finally {
				if (session != null) {
					session.close();
				}
			}
			System.out.println("Retrieved product name: " + retrievedName);


	
	Advantages of using MySQL : 
		. Open-source: Free to use and modify, fostering a large developer community and wide availability.
		. Performance: Generally considered fast and efficient, especially for smaller to medium-sized datasets.
		. Scalability: Can handle large datasets and high traffic volumes, often scaling horizontally by adding more servers.
		. Ease of use: Relatively simple to learn and use, with a well-documented syntax and many tools available.
		. Portability: Runs on various operating systems, making it adaptable to different environments.
		
	Data type in MySQL : 
		. Numeric: INT (integers), FLOAT (decimal numbers), DECIMAL (fixed-point decimals).
		. Character: CHAR (fixed-length strings), VARCHAR (variable-length strings), TEXT (long text strings).
		. Date/Time: DATE, TIME, DATETIME, TIMESTAMP.
		. Others: ENUM (predefined set of values), SET (multiple values from a set).
		
		eg-
			CREATE TABLE users (
				id INT PRIMARY KEY AUTO_INCREMENT,
				username VARCHAR(50) NOT NULL UNIQUE,
				email VARCHAR(100) NOT NULL UNIQUE,
				created_at DATETIME DEFAULT CURRENT_TIMESTAMP
			);

	Difference between a primary key and a unique key : 
		. Primary key: 
			A column (or group of columns) that uniquely identifies each row in a table. There can only be one primary key per table, and it cannot contain null values.
		. Unique key: 
			A column (or group of columns) that ensures no duplicate values exist within that column(s). A table can have multiple unique keys in addition to the primary key, and they can allow null values.
			
		eg- 
			CREATE TABLE products (
				product_id INT PRIMARY KEY AUTO_INCREMENT,
				name VARCHAR(255) NOT NULL UNIQUE,
				category VARCHAR(50) NOT NULL,
				price DECIMAL(10, 2) NOT NULL
			);
			
			In this example, product_id is the primary key, uniquely identifying each product. The name column has a unique key constraint, ensuring no duplicate product names exist.
		
		
		
	Joins in MySQL : 
		. Inner join: Returns rows where there is a match in both tables based on the join condition.
		eg-
			SELECT orders.order_id, customers.name, products.product_name
			FROM orders
			INNER JOIN customers ON orders.customer_id = customers.id
			INNER JOIN products ON orders.product_id = products.id;

		. Left join: Returns all rows from the left table and matching rows from the right table. If there's no match in the right table, null values are returned for unmatched columns.
		. Right join: Similar to a left join, but returns all rows from the right table and matching rows from the left.
		. Full join: Returns all rows from both tables, including unmatched rows with null values in the non-matching table.

	Explain how indexes work in MySQL :
		. Indexes are data structures that act like an index in a book, speeding up data retrieval in MySQL. They map specific values in a column or group of columns to the corresponding row locations in the table.
		. When you query a table using a WHERE clause that references an indexed column, MySQL can quickly locate the relevant rows using the index instead of scanning the entire table.
		eg;
			CREATE TABLE articles (
				id INT PRIMARY KEY AUTO_INCREMENT,
				title VARCHAR(255) NOT NULL,
				content TEXT,
				category VARCHAR(50) NOT NULL,
				INDEX (category)  // -- Create an index on the 'category' column
			);

	
	
	Stored procedure in MySQL : 
		A stored procedure in MySQL is a predefined block of SQL statements that you can save and reuse with a single call. It acts like a subroutine or a mini-program within the database itself. 
	
	Here are some key characteristics of stored procedures:
	Functionality:
		. Groups multiple SQL statements into a named unit, promoting code reusability and modularity.
		. Can accept input parameters, making them flexible for handling different scenarios.
		. May return output values or modify data based on the logic within the procedure.
	
	Benefits:
		. Reusability: Avoids rewriting complex SQL queries in multiple places, streamlining code and simplifying maintenance.
		. Modular Design: Encapsulates data access logic, improving code organization and readability.
		. Security: Can enforce data access control by implementing business logic within the procedure instead of directly in application code.
		. Performance: In certain cases, stored procedures can improve performance by pre-compiling the SQL statements and reducing network traffic (if sending fewer, more complex procedures instead of many individual queries).
	
	Structure:
		A stored procedure is created using the CREATE PROCEDURE statement. 
		
		It typically consists of three parts: 
			. Procedure Name: A unique identifier for the procedure.
			. Parameters (Optional): Input, output, or inout parameters to allow for dynamic behavior.
			. SQL Statements: The actual SQL code that defines the procedure's logic, often involving SELECT, INSERT, UPDATE, DELETE, or other database operations.
			
		Example : 
			CREATE PROCEDURE calculate_order_total(IN order_id INT)
			BEGIN
			  DECLARE total DECIMAL(10, 2);

			  SELECT SUM(price * quantity) INTO total
			  FROM order_items
			  WHERE order_id = order_id;

			  SELECT total;
			END;
			
		This procedure takes an order_id as input, calculates the total price by summing the product of price and quantity for all items in the order, and then returns the total value.

	
	
	
	View in MySQL :
		A view is a virtual table that provides a customized way to see data from underlying tables. It doesn't store data itself but presents a query result as if it were a table. Views can simplify complex queries, enforce data security by restricting access to certain columns, and improve code reusability.
		
		eg- 
			CREATE VIEW active_users AS
			SELECT id, username, email
			FROM users
			WHERE status = 'active';

		This creates a view named active_users that shows only users with an active status from the users table.
		
		
	How Transactions work in MySQL : 
		A transaction is a logical unit of work that involves one or more SQL statements. Transactions ensure data consistency by guaranteeing that all changes within a transaction either succeed entirely or fail completely. 
		
		They maintain data integrity through four properties:
		. Atomicity: All statements in a transaction are treated as a single unit. Either all succeed or all fail.
		. Consistency: The transaction brings the database from one valid state to another.
		. Isolation: Transactions are isolated from each other, preventing data inconsistencies caused by concurrent access.
		. Durability: Once a transaction commits, the changes become permanent.
		
		eg-
			START TRANSACTION;
			INSERT INTO orders (customer_id, product_id, quantity) VALUES (1, 10, 2);
			UPDATE inventory SET stock = stock - 2 WHERE product_id = 10;
			COMMIT;
			
		This transaction attempts to place an order and update the inventory. If either statement fails, the entire transaction is rolled back, ensuring data integrity.


	
	Optimize queries in MySQL :
		. Proper indexing: Create indexes on columns frequently used in WHERE clauses and JOIN conditions.
			Non-optimal query:
				SELECT * FROM users WHERE username = 'john_doe';
			
			Optimized query with index:
				CREATE INDEX idx_username ON users(username);  // Create an index on the username column
				SELECT * FROM users WHERE username = 'john_doe';

		. EXPLAIN plan: Use the EXPLAIN statement to analyze query execution plans and identify bottlenecks.
			Original query:
				SELECT * FROM orders o
				INNER JOIN order_items oi ON o.id = oi.order_id
				WHERE o.status = 'shipped' AND oi.product_category = 'electronics';
			
			Analyze the query plan:
				EXPLAIN SELECT * FROM orders o
				INNER JOIN order_items oi ON o.id = oi.order_id
				WHERE o.status = 'shipped' AND oi.product_category = 'electronics';

		. Optimize WHERE clauses: Avoid using negation (NOT) in WHERE clauses as it can force full table scans. Consider rewriting complex conditions.
			Non-optimal query (avoid negation in WHERE):
				SELECT * FROM products WHERE category != 'clothing';
					This query forces a full table scan because the database needs to check every row to see if the category is not clothing.
			
			Optimized query (use positive condition):
				SELECT * FROM products WHERE category = 'clothing' OR category IS NULL;

			
			
		. *Minimize SELECT : Only select the columns you actually need, avoiding unnecessary data retrieval.
			Non-optimal query:
				SELECT * FROM customers; // -- Selects all columns, even if not all are needed

			Optimized query:
				SELECT customer_id, name, email FROM customers;  // -- Selects only the needed columns

		. Use appropriate data types: Choose data types that efficiently store the actual data values.
			Non-optimal:
				CREATE TABLE products (
					id INT,
					price VARCHAR(255) // -- Using string to store price (inefficient)
				);
				
			Optimized:
				CREATE TABLE products (
					id INT,
					price DECIMAL(10,2) // -- Using appropriate decimal data type
				);


		
		
	Replication techniques in MySQL :
		Replication allows you to copy data from a primary server (master) to one or more secondary servers (slaves). This enhances data redundancy, scalability, and fault tolerance. 
		
		Common replication methods include:
		. Master-slave replication: Asynchronous data replication from the master to slaves.
		. Multi-master replication: Enables updates on any master, requiring careful configuration to maintain data consistency.
		
	
	Normalization in a database : 
		Normalization is the process of organizing tables to minimize redundancy and improve data integrity. It involves breaking down tables into smaller, more focused tables with defined relationships using primary and foreign keys. Different normal forms (1NF, 2NF, 3NF, etc.) define progressive levels of data organization.
		
		
		
	How would you handle a large dataset that doesn't fit comfortably in a single MySQL table :
	. Partitioning: Divide the table horizontally by splitting data across multiple tables based on a defined partition key (e.g., date range, customer ID).
	. Sharding: Vertically partition data across multiple servers based on a sharding key (e.g., user ID).
	. NoSQL databases: Consider using NoSQL databases (e.g., MongoDB) for very large or unstructured datasets that don't require the strict schema enforcement of relational databases.
	




===========================================================================================


application.properties :
------------------------


server.port = 8081

spring.application.name=crudwithdao

spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/crudwithdao?createDatabaseIfNotExist=true 

spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
spring.jpa.generate-ddl=true
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

# Pagination settings
#spring.data.web.pageable.default-page-size=10
#spring.data.web.pageable.max-page-size=50
#spring.data.web.pageable.page-parameter=pageNo
#spring.data.web.pageable.size-parameter=pageSize




===========================================================================================


SPRINGBOOT : 
------------

Spring Boot : 
	Spring Boot is a framework for rapidly creating production-ready Java applications. 
	
	It simplifies development by:
		* Auto-configuration: Saves time by automatically configuring beans based on project dependencies.
		* Starters: Provides pre-configured dependency management for features like web apps and data access.
		* Embedded servers: Enables running the application without a separate server container.

	Benefits of using Spring Boot :
		. Increased developer productivity
		. Reduced boilerplate code
		. Convention over configuration approach
		. Easier deployment to production
		. Built-in monitoring and management features
		
	How do you create a Spring Boot application : 
		You can use Spring Initializr (https://start.spring.io) to easily set up a Spring Boot project. Specify project details like group, name, and desired dependencies (e.g., web, database). It generates a basic project structure with Maven or Gradle configuration.

	@SpringBootApplication annotation :
		This annotation marks a class as the main configuration class for a Spring Boot application. It enables component scanning, auto-configuration, and serves as an entry point for the application.

	Spring Boot Starters : 
		Starters are pre-configured dependency sets for common functionalities like web development, data access (e.g., JPA), and security (Spring Security). Including a starter in your project automatically pulls in all the necessary libraries.

	How does auto-configuration work in Spring Boot : 
		Spring Boot scans for dependencies on your classpath and automatically configures beans based on conventions. For example, including the spring-boot-starter-web dependency automatically configures Tomcat as an embedded server.

	Profiles in Spring Boot : 
		Profiles allow you to configure different application environments (e.g., development, testing, production). You can activate profiles using environment variables or command line arguments. Configuration properties specific to a profile are only loaded when that profile is active.

	Configure a datasource in Spring Boot : 
		Spring Boot auto-configures a datasource based on available libraries (e.g., HikariCP). You only need to provide connection details like URL, username, and password in your application.yml or application.properties file.

	Spring Boot Actuator : 
		Spring Boot Actuator provides production-ready features for monitoring and managing your application. It exposes endpoints for health checks, metrics, environment information, and more. You can access these endpoints for application diagnostics and configuration.

	How do you secure a Spring Boot application : 
		Spring Security is a popular integration for securing Spring Boot applications. It provides features like user authentication, authorization, and session management. You can configure authentication methods (e.g., basic, JWT) and access control rules for your application resources.

	Customize auto-configuration in Spring Boot : 
		. You can disable auto-configuration for specific beans using @EnableAutoConfiguration(exclude = {MyBean.class}).
		. Annotations like @ConfigurationProperties allow you to customize bean configuration with properties.
		. You can provide custom bean definitions with the @Bean annotation to override auto-configured beans.
		
	How do you package a Spring Boot application for deployment :
		Spring Boot applications can be packaged as executable JAR files with the spring-boot-maven-plugin or spring-boot-gradle-plugin. This creates a single JAR containing all dependencies and your application code, simplifying deployment.

	Explain logging in Spring Boot : 
		Spring Boot integrates with common logging frameworks like Logback. You can configure logging levels and destinations (e.g., console, file) in your application properties file.

	What are some best practices for developing Spring Boot applications : 
		. Use dependency injection for loose coupling and testability.
		. Implement unit and integration tests for your code.
		. Leverage Spring Boot features like profiles and Actuator for better application management.
		. Follow Spring Boot conventions for a well-structured and maintainable codebase.
		
	How DI Works in Spring Boot : 
		Spring Boot leverages constructor injection by default, where the required dependencies are specified as constructor arguments. 
		
			@Service
			public class MyService {
				private final MyRepository repository; // Dependency Injection of MyRepository
				public MyService(MyRepository repository) {
					this.repository = repository;
				}

				public void doSomething() {
					// Use the injected repository for data access
					repository.fetchData();
				}
			}
			
			. MyService declares a constructor that takes a MyRepository object as an argument.
			. Spring Boot, during application startup, scans for beans (managed objects) and their dependencies.
			. When it encounters MyService, it first instantiates MyRepository.
			. Then, it creates a new instance of MyService, injecting the already-created MyRepository into its constructor.

		
	How do you handle errors in a Spring Boot application : 
		Spring Boot provides features like @ControllerAdvice for centralized exception handling. You can define custom error responses and exception mapping for specific error scenarios.
		
	

===========================================================================================

===========================================================================================
	
	
	
MICROSERVICES :

Microservice : 
	Microservices are a software development architecture style where an application is built as a collection of small, independent services. Each service focuses on a single business capability and communicates with others through well-defined APIs.
	
	. Example: 
		An e-commerce application could have separate microservices for product management, user management, shopping cart, and order processing.

Benefits of using microservices architecture :
	. Scalability: Services can be scaled independently based on their needs.
	. Agility: Easier to develop, deploy, and update individual services.
	. Resilience: Failure in one service doesn't bring down the entire application.
	. Loose Coupling: Changes in one service have minimal impact on others.
	
	Example: 
		During a sale, the product management service can be scaled up to handle increased traffic, while the user management service can maintain its usual capacity.

How do microservices communicate with each other :
	Microservices can communicate through various mechanisms like REST APIs, message queues, or event sourcing.
	
	Synchronous Communication
		HTTP/REST:
			Description: Microservices often use HTTP/REST APIs to communicate synchronously. Each service exposes RESTful endpoints that other services can call.
			Advantages: Simple, widely supported, and well-understood.
			Disadvantages: Can lead to tight coupling and higher latency, and is not as resilient to failures.
			
			Example: The shopping cart service might use a REST API to communicate with the product service to retrieve product details.
		
		gRPC:
			Description: gRPC is a high-performance RPC framework that uses HTTP/2 for transport, Protocol Buffers for serialization, and supports multiple programming languages.
			Advantages: Efficient, supports multiple languages, and provides features like authentication, load balancing, and more.
			Disadvantages: More complex setup compared to REST, requires understanding of Protocol Buffers.
		
		
	Asynchronous Communication
		Message Brokers (e.g., RabbitMQ, Apache Kafka):
			Description: Services communicate by sending messages to a broker, which then forwards these messages to the appropriate service.
			Advantages: Decouples services, improves resilience and scalability, and handles spikes in traffic more gracefully.
			Disadvantages: More complex architecture, potential for message loss if not handled properly.
		
		Event Streaming (e.g., Apache Kafka, Amazon Kinesis):
			Description: Services produce and consume streams of events, which are stored in a log for processing.
			Advantages: High throughput, scalability, and decoupling of services.
			Disadvantages: Requires management of event streams, potential complexity in ensuring exactly-once processing.
		
		
	Other Communication Patterns
		Service Meshes (e.g., Istio, Linkerd):
			Description: A dedicated infrastructure layer that handles service-to-service communication, including load balancing, authentication, authorization, and observability.
			Advantages: Enhances security, reliability, and observability without requiring changes to application code.
			Disadvantages: Adds complexity to deployment and management.
		
		GraphQL:
			Description: An alternative to REST where clients can request exactly the data they need from multiple services in a single query.
			Advantages: Reduces over-fetching and under-fetching of data, improves flexibility.
			Disadvantages: Can be more complex to implement and requires managing a schema.
	
	
	
	
Difference between monolithic and microservices architecture :
	A monolithic application is a single, large codebase. 
	And Microservices break down the functionality into smaller, independent services.

	. Example: 
		A monolithic e-commerce application would have all functionalities like product management and order processing tightly coupled in one codebase. In a microservices architecture, these would be separate services.
		
		

Design and Implementation:
--------------------------

Service discovery in microservices :
	Service discovery allows microservices to find each other at runtime. Tools like ZooKeeper or Consul help register and locate services.

	. Example: 
		The shopping cart service can use a service discovery registry to locate the product service dynamically.
		
		
How do you handle data consistency in microservices :
	Data consistency across services can be achieved through techniques like eventual consistency or ACID transactions.

	. Example: 
		Eventually consistent data models might be suitable for the shopping cart service (products added might reflect with a slight delay), while order processing might require ACID transactions for financial data integrity.


API Gateway pattern :
	An API Gateway acts as a single entry point for clients to interact with various microservices. It can provide functionalities like routing, authentication, and security.

	. Example: 
		The API Gateway in the e-commerce application would receive a user request, route it to the appropriate microservice (product, user, etc.), and aggregate the response before sending it back to the client.
		
		

Advanced Concepts:
------------------

Explain Circuit Breaker pattern in microservices :
	The Circuit Breaker pattern is a fault tolerance mechanism commonly used in microservices architectures. It acts like a safety switch, protecting your system from cascading failures and improving overall resilience.

	. How it Works:
		The Circuit Breaker operates in three main states:

		. Closed: This is the initial state where the circuit breaker allows normal communication between services. Requests are passed through to the dependent service.
		
		. Open: When the Circuit Breaker encounters a predefined number of failures (e.g., consecutive timeouts or errors) within a specific timeframe, it trips to the Open state. This essentially throws a switch, blocking further requests to the failing service. This prevents your application from relentlessly hammering a service that's already under strain.
		
		. Half-Open: After a configured timeout period (e.g., 10 seconds), the Circuit Breaker enters the Half-Open state. It allows a single "health check" request to pass through. If the health check succeeds (i.e., the service responds successfully), the Circuit Breaker resets to the Closed state, resuming normal communication. However, if the health check fails, the Circuit Breaker flips back to the Open state, extending the timeout period before another attempt.
		
		Benefits:
			. Resilience: Isolates failures in one service, preventing them from cascading and bringing down the entire system.
			
			. Fault Tolerance: Gracefully degrades functionality by using fallback strategies when a service is unavailable.
			
			. Improved Performance: Reduces load on an overloaded service, allowing it to recover.
			
		Example:
			Consider a shopping cart microservice that relies on a product inventory microservice to display product information. Here's how the Circuit Breaker can be implemented:
				
				// ShoppingCartService
				@Service
				public class ShoppingCartService {

					private ProductService productService;
					private CircuitBreaker circuitBreaker; // Assuming a Circuit Breaker library

					public ShoppingCart getCart(Long userId) {
						ShoppingCart cart = ...;
						for (CartItem item : cart.getItems()) {
							try {
								Product product = circuitBreaker.run(() -> productService.getProduct(item.getProductId()));
								item.setProduct(product);
							} catch (Exception e) {
								// Fallback strategy: Use a default product name or display an error message
								item.setProductName("Product Unavailable");
							}
						}
						return cart;
					}
				}
				
			By implementing the Circuit Breaker pattern, you can create more robust and fault-tolerant microservices architectures that can effectively handle service failures and maintain overall system uptime.


		

What are some tools and frameworks used for developing microservices?
	Popular tools include Spring Boot, Docker, Kubernetes, Kafka, and Istio.

	. Example: 
		Spring Boot can be used to develop and deploy individual microservices, while Docker containers can package and isolate them. Kubernetes manages containerized microservices at scale.
		
		
		
Troubleshooting and Best Practices:
-----------------------------------

How do you debug and monitor microservices?
	Logging, distributed tracing tools like Zipkin, and monitoring dashboards like Prometheus can help identify and troubleshoot issues in microservices.

	. Example: 
		Distributed tracing allows you to follow a user request across various microservices, pinpointing where a problem might occur.
		
		
What are some challenges associated with microservices?
	Challenges include increased complexity, distributed system management, and potential for data inconsistency.

	. Example: 
		Managing dependencies and ensuring data consistency across multiple services can be complex compared to a monolithic architecture.
		

How do you handle deployments and rollbacks in a microservices environment?
	Deployment strategies like blue-green deployments or canary releases can help minimize downtime during updates.

	. Example: 
		In a blue-green deployment, you can switch traffic from the old version of a microservice (blue) to the new version (green) gradually, allowing for rollback if needed.
		
		
		
What are some best practices for designing secure microservices :
	Securing microservices requires a comprehensive approach. 
	
	Here are some best practices:
	. Authentication and Authorization: Implement robust mechanisms (e.g., JWT, OAuth) to verify user and service identities and control access to resources.
	. API Security: Secure APIs with techniques like HTTPS, rate limiting, and input validation to prevent unauthorized access and attacks.
	. Data Encryption: Encrypt sensitive data at rest and in transit to protect it from breaches.
	. Least Privilege: Grant services and users only the minimum permissions they need.
	. Security Monitoring: Continuously monitor for suspicious activity and vulnerabilities in microservices and their communication.
	
	. Example: 
		The e-commerce application's API Gateway can implement JWT tokens for user authentication and authorization. Each microservice might have its own access control policies to restrict unauthorized access to data.



Explain how you can test microservices effectively :
	Testing microservices requires a multi-layered approach:
	. Unit Tests: Test individual microservice functionalities in isolation.
	. Integration Tests: Verify how microservices interact with each other.
	. Contract Testing: Ensure compatibility between services through tools like Pact.
	. End-to-End Tests: Simulate user journeys and test the overall application flow.
	
	. Example: 
		Unit tests can ensure the shopping cart service correctly calculates cart totals. Integration tests can verify how the shopping cart service interacts with the product service to retrieve product details. Pact can be used to define and test the contract between the shopping cart service and its dependencies. Finally, end-to-end tests can simulate a user adding products to the cart and completing a purchase, ensuring the entire workflow functions as expected.
		
		
		
		

===========================================================================================
	
Install node
Install nvm
npm install -g @angular/cli

Windows PowerShell :
C:\Windows\system32> Set-ExecutionPolicy RemoteSigned
Do you want to change the execution policy?
[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help
(default is "N"):A

C:\Windows\system32> Get-ExecutionPolicy
RemoteSigned



C:\Users\vikyr>ng v

     _                      _                 ____ _     ___
    / \   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|
   / △ \ | '_ \ / _` | | | | |/ _` | '__|   | |   | |    | |
  / ___ \| | | | (_| | |_| | | (_| | |      | |___| |___ | |
 /_/   \_\_| |_|\__, |\__,_|_|\__,_|_|       \____|_____|___|
                |___/


Angular CLI: 18.0.0
Node: 20.13.1
Package Manager: npm 10.8.0
OS: win32 x64

Angular:
...

Package                      Version
------------------------------------------------------
@angular-devkit/architect    0.1800.0 (cli-only)
@angular-devkit/core         18.0.0 (cli-only)
@angular-devkit/schematics   18.0.0 (cli-only)
@schematics/angular          18.0.0 (cli-only)


C:\Users\vikyr>node --version
v20.13.1

C:\Users\vikyr>npm --version
10.8.0

-- downgrade npm version : 
C:\Users\vikyr>npm install -g npm@10.8.0

C:\Users\vikyr>nvm -v
1.1.12





> ng new <project>
> cd project
\angular> cd src
\angular\src> cd app
\angular\src\app> mkdir components
\angular\src\app> cd components
\angular\src\app\components> ng g c firstComponent
\angular\src\app\components> ng g c inlineStyleComponent --inline-style
\angular\src\app\components> ng g c inlineTemplateComponent--inline-template 
\angular\src\app\components> ng g c inlineStyleTemplateComponent --inline-style --inline-template 


\angular\src\app\components> cd ..\ 
\angular\src\app> mkdir modules
\angular\src\app> cd modules
\angular\src\app\modules> ng g m firstModule   
\angular\src\app\modules> cd first-module
\angular\src\app\modules\first-module> ng g c modelFirstComponent
\angular\src\app\modules\first-module> ng g c modelSecondComponent

ng serve

Shortcuts
  press r + enter to force reload browser
  press u + enter to show server url
  press o + enter to open in browser
  press c + enter to clear console
  press q + enter to quit
  
  


===========================================================================================

AngularJS : 
	AngularJS is an open-source front-end web application framework maintained by Google. It helps developers build dynamic web applications by providing a model-view-controller (MVC) architecture and components commonly used in web development. AngularJS extends HTML with additional attributes and binds data to HTML with expression
	
	<!DOCTYPE html>
	<html>
	<head>
		<title>AngularJS Example</title>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
	</head>
	<body ng-app="myApp" ng-controller="myController">
		<p>{{ message }}</p>
		<script>
			var app = angular.module('myApp', []);
			app.controller('myController', function($scope) {
				$scope.message = "Hello, AngularJS!";
			});
		</script>
	</body>
	</html>
	
	In this example, AngularJS is used to bind the message variable to the HTML paragraph. The ng-app directive initializes the AngularJS application, and ng-controller specifies the controller.



Directives in AngularJS : 
	Directives are special markers on a DOM element (such as an attribute, element name, comment, or CSS class) that tell AngularJS to do something to that DOM element or even its children. AngularJS has built-in directives (e.g., ngBind, ngModel, ngClass), and you can also create custom directives.
	
	<!DOCTYPE html>
	<html>
	<head>
		<title>AngularJS Directives</title>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
	</head>
	<body ng-app="myApp">
		<input type="text" ng-model="name">
		<p ng-bind="name"></p>
	</body>
	</html>
	
	Here, ng-model binds the input field to the name variable, and ng-bind updates the paragraph content whenever name changes.


Two-way data binding :
	Two-way data binding in AngularJS synchronizes the data between the model and the view. Any change in the model updates the view and vice versa.
	
	<!DOCTYPE html>
	<html>
	<head>
		<title>Two-Way Data Binding</title>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
	</head>
	<body ng-app="myApp" ng-controller="myController">
		<input type="text" ng-model="greeting">
		<p>{{ greeting }}</p>
		<script>
			var app = angular.module('myApp', []);
			app.controller('myController', function($scope) {
				$scope.greeting = "Hello, World!";
			});
		</script>
	</body>
	</html>
	
	In this example, changing the input field value updates the paragraph text in real-time and vice versa.
	
	
Concept of scope in AngularJS : 
	Scope is an object that refers to the model. It acts as a glue between the controller and the view. Scopes are arranged in a hierarchical structure, mimicking the DOM structure of the application. They provide a mechanism for watching the model and updating the view whenever the model changes.
	
	<!DOCTYPE html>
	<html>
	<head>
		<title>AngularJS Scope</title>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
	</head>
	<body ng-app="myApp" ng-controller="parentController">
		<p>Parent Message: {{ parentMessage }}</p>
		<div ng-controller="childController">
			<p>Child Message: {{ childMessage }}</p>
		</div>
		<script>
			var app = angular.module('myApp', []);
			app.controller('parentController', function($scope) {
				$scope.parentMessage = "Message from Parent";
			});
			app.controller('childController', function($scope) {
				$scope.childMessage = "Message from Child";
			});
		</script>
	</body>
	</html>
	
	In this example, there are two controllers with their own scopes. The parent controller's scope is accessible within the child controller's scope.
	
	
Services in AngularJS : 
	Services in AngularJS are singleton objects or functions that carry out specific tasks common to multiple modules. They can be created using .service(), .factory(), .provider(), or .value() methods.
	
	Example using .factory():
	
		<!DOCTYPE html>
		<html>
		<head>
			<title>AngularJS Services</title>
			<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
		</head>
		<body ng-app="myApp" ng-controller="myController">
			<p>Random Number: {{ randomNumber }}</p>
			<button ng-click="generateRandomNumber()">Generate</button>
			<script>
				var app = angular.module('myApp', []);
				app.factory('randomNumberService', function() {
					return {
						generate: function() {
							return Math.floor(Math.random() * 100);
						}
					};
				});
				app.controller('myController', function($scope, randomNumberService) {
					$scope.generateRandomNumber = function() {
						$scope.randomNumber = randomNumberService.generate();
					};
				});
			</script>
		</body>
		</html>
		
	Here, randomNumberService is a factory service that generates a random number, which is used in the controller.
	
	
Dependency injection in AngularJS : 
	Dependency Injection (DI) is a software design pattern that deals with how components get hold of their dependencies. In AngularJS, DI helps manage components dependencies by providing a consistent way to create and inject them into controllers, services, and other components.
	
	<!DOCTYPE html>
	<html>
	<head>
		<title>Dependency Injection</title>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
	</head>
	<body ng-app="myApp" ng-controller="myController">
		<p>{{ message }}</p>
		<script>
			var app = angular.module('myApp', []);
			app.service('myService', function() {
				this.getMessage = function() {
					return "Hello from the service!";
				};
			});
			app.controller('myController', function($scope, myService) {
				$scope.message = myService.getMessage();
			});
		</script>
	</body>
	</html>

	In this example, myService is injected into myController, and the controller uses it to set the message scope variable.


Controller in AngularJS :
	A controller in AngularJS is a JavaScript function that is used to build the model for the view. It acts as a link between the view and the model. Controllers are used to define the behavior and data of the application's scope.
	
	<!DOCTYPE html>
	<html>
	<head>
		<title>AngularJS Controller</title>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
	</head>
	<body ng-app="myApp" ng-controller="myController">
		<p>{{ greeting }}</p>
		<button ng-click="changeGreeting()">Change Greeting</button>
		<script>
			var app = angular.module('myApp', []);
			app.controller('myController', function($scope) {
				$scope.greeting = "Hello, World!";
				$scope.changeGreeting = function() {
					$scope.greeting = "Hello, AngularJS!";
				};
			});
		</script>
	</body>
	</html>
	
	In this example, myController sets the initial greeting and defines a function to change the greeting when the button is clicked.
	
	
Filters in AngularJS : 
	Filters in AngularJS are used to format the data displayed to the user. They can be used in view templates, controllers, or services. AngularJS comes with several built-in filters, such as currency, date, filter, json, limitTo, lowercase, number, orderBy, and uppercase.
	
	<!DOCTYPE html>
	<html>
	<head>
		<title>AngularJS Filters</title>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
	</head>
	<body ng-app="myApp" ng-controller="myController">
		<p>Original: {{ amount }}</p>
		<p>Currency: {{ amount | currency }}</p>
		<p>Uppercase: {{ name | uppercase }}</p>
		<script>
			var app = angular.module('myApp', []);
			app.controller('myController', function($scope) {
				$scope.amount = 1234.56;
				$scope.name = "angularjs";
			});
		</script>
	</body>
	</html>
	
	In this example, filters are used to format a number as currency and to convert a string to uppercase.
	

Routing in AngularJS : 
	Routing in AngularJS is used to create single-page applications (SPAs). It allows you to navigate between different views or pages without reloading the entire application. AngularJS provides the ngRoute module to configure routes.
	
	<!DOCTYPE html>
	<html>
	<head>
		<title>AngularJS Routing</title>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular-route.min.js"></script>
	</head>
	<body ng-app="myApp">
		<a href="#!/">Home</a>
		<a href="#!/about">About</a>
		<div ng-view></div>
		<script>
			var app = angular.module('myApp', ['ngRoute']);
			app.config(function($routeProvider) {
				$routeProvider
				.when("/", {
					template : "<h1>Home</h1><p>Welcome to the home page!</p>"
				})
				.when("/about", {
					template : "<h1>About</h1><p>Learn more about us on this page.</p>"
				})
				.otherwise({
					redirectTo: '/'
				});
			});
		</script>
	</body>
	</html>
	
	In this example, the ngRoute module is used to define routes for the home and about pages.


Modules in AngularJS : 
	Modules in AngularJS are containers for different parts of your application, such as controllers, services, filters, directives, etc. They help in organizing the code in a structured manner and managing dependencies.
	
	<!DOCTYPE html>
	<html>
	<head>
		<title>AngularJS Modules</title>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
	</head>
	<body ng-app="myApp" ng-controller="myController">
		<p>{{ message }}</p>
		<script>
			var app = angular.module('myApp', []);
			app.controller('myController', function($scope) {
				$scope.message = "Hello from the module!";
			});
		</script>
	</body>
	</html>
	
	In this example, myApp is an AngularJS module that contains the myController controller.
	
	
Difference between ng-if and ng-show/ng-hide : 
	. ng-if: Conditionally includes or removes an element from the DOM based on the evaluation of an expression. If the expression evaluates to true, the element is included; otherwise, it is removed.
	. ng-show / ng-hide: Conditionally shows or hides an element based on the evaluation of an expression. The element remains in the DOM, but its visibility is toggled using CSS.
	
	<!DOCTYPE html>
	<html>
	<head>
		<title>ng-if vs ng-show/ng-hide</title>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
	</head>
	<body ng-app="myApp" ng-controller="myController">
		<button ng-click="toggle()">Toggle</button>
			<p ng-if="isVisible">This is visible with ng-if</p>
		<p ng-show="isVisible">This is visible with ng-show</p>
		<p ng-hide="!isVisible">This is visible with ng-hide</p>
		<script>
			var app = angular.module('myApp', []);
			app.controller('myController', function($scope) {
				$scope.isVisible = true;
				$scope.toggle = function() {
					$scope.isVisible = !$scope.isVisible;
				};
			});
		</script>
	</body>
	</html>
	
	In this example, ng-if will remove the paragraph from the DOM when isVisible is false, while ng-show and ng-hide will just toggle the visibility of the paragraphs.


How do you create a custom directive in AngularJS : 
	A custom directive in AngularJS allows you to extend HTML's functionality. You can create reusable components with custom behavior. Custom directives are created using the directive method.
	
	<!DOCTYPE html>
	<html>
	<head>
		<title>Custom Directive</title>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
	</head>
<body ng-app="myApp">
    <hello-world></hello-world>
    <script>
        var app = angular.module('myApp', []);
        app.directive('helloWorld', function() {
				return {
					template: '<h1>Hello, World!</h1>'
				};
			});
		</script>
	</body>
	</html>
	
	In this example, the helloWorld custom directive is created, which renders "Hello, World!" wherever it is used in the HTML.


$scope object : 
	The $scope object in AngularJS is used to pass data between the controller and the view. It acts as a bridge between the view and the controller, allowing you to store data and functions that can be accessed and manipulated within the view.
	
	<!DOCTYPE html>
	<html>
	<head>
		<title>$scope Object</title>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
	</head>
	<body ng-app="myApp" ng-controller="myController">
		<p>{{ message }}</p>
		<button ng-click="changeMessage()">Change Message</button>
		<script>
			var app = angular.module('myApp', []);
			app.controller('myController', function($scope) {
				$scope.message = "Hello, World!";
				$scope.changeMessage = function() {
					$scope.message = "Hello, AngularJS!";
				};
			});
		</script>
	</body>
	</html>
	
	In this example, the $scope object holds the message variable and the changeMessage function, which updates the message.


What is the $http service in AngularJS : 
	The $http service in AngularJS is used to make HTTP requests to a remote server. It supports all the HTTP methods, including GET, POST, PUT, DELETE, etc. The service returns a promise, which allows you to handle the response asynchronously.
	
	<!DOCTYPE html>
	<html>
	<head>
		<title>$http Service</title>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
	</head>
	<body ng-app="myApp" ng-controller="myController">
		<p>Data: {{ data }}</p>
		<script>
			var app = angular.module('myApp', []);
			app.controller('myController', function($scope, $http) {
				$http.get('https://jsonplaceholder.typicode.com/posts/1')
					.then(function(response) {
						$scope.data = response.data;
					}, function(error) {
						$scope.data = "Error: " + error.statusText;
					});
			});
		</script>
	</body>
	</html>
	
	In this example, the $http service is used to make a GET request to a public API. The response data is then bound to the data variable in the scope.


What is the difference between $scope and scope : 

	. $scope: It is an AngularJS service that is injected into the controller function and other components. It is used to bind data and functions between the controller and the view.
	
	. scope: Typically refers to a generic term used to describe the concept of scope in JavaScript, which is the context in which variables and functions are accessible.
	
	In AngularJS, $scope is a specific implementation that provides a context for the model in the application.
	
	<!DOCTYPE html>
	<html>
	<head>
		<title>$scope vs scope</title>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
	</head>
	<body ng-app="myApp" ng-controller="myController">
		<p>{{ message }}</p>
		<script>
			var app = angular.module('myApp', []);
			app.controller('myController', function($scope) {
				$scope.message = "Hello, World!";
			});
		</script>
	</body>
	</html>
	
	In this example, $scope is used within the controller to bind data to the view.


Digest Cycle in AngularJS : 
	The digest cycle is the process that AngularJS uses to check for changes in the scope model and update the DOM accordingly. It involves evaluating all the watchers in the application, checking if the values have changed, and then updating the view if necessary. The digest cycle can be triggered by user interactions (e.g., clicks, keypresses) or manually using $apply or $digest.
	
	<!DOCTYPE html>
	<html>
	<head>
		<title>Digest Cycle</title>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
	</head>
	<body ng-app="myApp" ng-controller="myController">
		<p>{{ message }}</p>
		<button ng-click="changeMessage()">Change Message</button>
		<script>
			var app = angular.module('myApp', []);
			app.controller('myController', function($scope) {
				$scope.message = "Hello, World!";
				$scope.changeMessage = function() {
					$scope.message = "Hello, AngularJS!";
					$scope.$digest(); // Manually triggering the digest cycle (for demonstration purposes)
				};
			});
		</script>
	</body>
	</html>
	
	In this example, the digest cycle is manually triggered using $digest, although this is usually not necessary as AngularJS handles it automatically.
	
AngularJS Promises : 
	Promises in AngularJS are provided by the $q service and represent a way to handle asynchronous operations. A promise represents an operation that hasn't completed yet but is expected to in the future. It can be in one of three states: pending, resolved, or rejected.
	
	<!DOCTYPE html>
	<html>
	<head>
		<title>AngularJS Promises</title>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
	</head>
	<body ng-app="myApp" ng-controller="myController">
		<p>{{ message }}</p>
		<script>
			var app = angular.module('myApp', []);
			app.controller('myController', function($scope, $q) {
				var asyncTask = function() {
					var deferred = $q.defer();
					setTimeout(function() {
						deferred.resolve("Hello, Promises!");
					}, 2000);
					return deferred.promise;
				};

				asyncTask().then(function(response) {
					$scope.message = response;
				});
			});
		</script>
	</body>
	</html>
	
	In this example, a promise is created using $q.defer, and it resolves after 2 seconds, updating the scope variable message.
	

How can you communicate between two controllers in AngularJS? : 
	Communication between controllers can be achieved using services, events, or the $rootScope. Services are the most preferred way as they provide a clean separation of concerns.
	
	Example using Services:
		<!DOCTYPE html>
		<html>
		<head>
			<title>Communication Between Controllers</title>
			<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
		</head>
		<body ng-app="myApp">
			<div ng-controller="controllerA">
				<p>{{ message }}</p>
			</div>
			<div ng-controller="controllerB">
				<button ng-click="updateMessage()">Update Message</button>
			</div>
			<script>
				var app = angular.module('myApp', []);
				app.service('sharedService', function() {
					var message = "Initial Message";
					return {
						getMessage: function() {
							return message;
						},
						setMessage: function(newMessage) {
							message = newMessage;
						}
					};
				});

				app.controller('controllerA', function($scope, sharedService) {
					$scope.message = sharedService.getMessage();
				});

				app.controller('controllerB', function($scope, sharedService) {
					$scope.updateMessage = function() {
						sharedService.setMessage("Updated Message from Controller B");
					};
				});
			</script>
		</body>
		</html>
	
	In this example, sharedService is used to share data between controllerA and controllerB.
	

$rootScope and $scope in AngularJS : 
	. $rootScope: It is the top-level scope that is available in the entire AngularJS application. Any variable or function attached to $rootScope can be accessed in any controller.
	
	. $scope: It is the scope object specific to the controller in which it is defined. Each controller has its own $scope.
	
	<!DOCTYPE html>
	<html>
	<head>
		<title>$rootScope vs $scope</title>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
	</head>
	<body ng-app="myApp" ng-controller="controllerA">
		<p>{{ globalMessage }}</p>
		<div ng-controller="controllerB">
			<p>{{ localMessage }}</p>
		</div>
		<script>
			var app = angular.module('myApp', []);
			app.run(function($rootScope) {
				$rootScope.globalMessage = "Hello from $rootScope!";
			});

			app.controller('controllerA', function($scope) {
				$scope.localMessage = "Hello from $scope in controller A!";
			});

			app.controller('controllerB', function($scope) {
				$scope.localMessage = "Hello from $scope in controller B!";
			});
		</script>
	</body>
	</html>
	
	In this example, globalMessage is defined on $rootScope and is accessible in both controllers, while localMessage is specific to each controller's $scope.
	
	
How do you handle errors in AngularJS applications : 
	Error handling in AngularJS can be done using the $http service's promise methods (.then and .catch) and $exceptionHandler for unhandled exceptions.

	Example using $http service:
		<!DOCTYPE html>
		<html>
		<head>
			<title>Error Handling in AngularJS</title>
			<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
		</head>
		<body ng-app="myApp" ng-controller="myController">
			<p>{{ data }}</p>
			<p ng-if="errorMessage">{{ errorMessage }}</p>
			<script>
				var app = angular.module('myApp', []);
				app.controller('myController', function($scope, $http) {
					$http.get('https://jsonplaceholder.typicode.com/posts/12345') // Invalid URL to trigger error
						.then(function(response) {
							$scope.data = response.data;
						})
						.catch(function(error) {
							$scope.errorMessage = "Error: " + error.statusText;
						});
				});
			</script>
		</body>
		</html>
		
	In this example, an invalid URL is used to trigger an error, which is then caught and displayed using the .catch method.

  

===========================================================================================

ANGULAR : 
---------

1. Components : 
	The building blocks of Angular applications. Each component encapsulates a view (template) and logic (TypeScript class).
	
	@Component({
		selector: 'app-product',
		templateUrl: './product.component.html',
		styleUrls: ['./product.component.css']
	})
	export class ProductComponent {
		name = 'T-Shirt';
		price = 19.99;
	}
	<h3>{{ name }}</h3>
	<p>Price: ${{ price }}</p>


2. Templates: 
	Written in HTML-like syntax with Angular expressions ({{ }}) to display dynamic data and directives for custom behavior.

	Example (continued from Component example):
		The template displays the name and price properties of the ProductComponent class using Angular expressions.
			
		<h3>{{ name }}</h3>
		<p>Price: ${{ price }}</p>
		
3. Directives: 
	Extend HTML functionality. Built-in directives like *ngFor for loops and [ngClass] for dynamic class assignment, or create custom directives.
	
	<ul>
		<li *ngFor="let item of items">{{ item }}</li>
	</ul>

	The *ngFor directive iterates over the items array, creating a list item for each element.
	
4. Services: 
	Reusable data or logic providers that can be injected into components.
	
	import { Injectable } from '@angular/core';

	@Injectable({
		providedIn: 'root'
	})
	export class ProductService {
		getProducts() {
			// Simulate fetching data from an API
			return [
				{ name: 'T-Shirt', price: 19.99 },
				{ name: 'Hat', price: 14.99 }
			];
		}
	}
	
	This ProductService provides methods for product data access, which components can inject.


5. Dependency Injection (DI): 
	A mechanism for providing components with dependencies (services, etc.) without manual instantiation.
	
	constructor(private productService: ProductService) {}
	ngOnInit() {
		this.products = this.productService.getProducts();
	}

	The ProductComponent injects the ProductService into its constructor for data access.


6. Modules: 
	Organize application code. Components, directives, services, and pipes are typically grouped into modules.
	
	import { NgModule } from '@angular/core';
	import { BrowserModule } from '@angular/platform-browser';

	import { AppComponent } from './app.component';
	import { ProductComponent } from './product/product.component';
	import { ProductService } from './product/product.service';

	@NgModule({
		declarations: [
			AppComponent,
			ProductComponent
		],
		imports: [
			BrowserModule
		],
		providers: [
			ProductService
		],
		bootstrap: [AppComponent]
	})
	export class AppModule { }



7. Routing: 
	Defines navigation between views in your application.
	
	const routes: Routes = [
	  { path: '', component: HomeComponent },
	  { path: 'products', component: ProductsComponent }
	];

	@NgModule({
	  imports: [RouterModule.forRoot(routes)],
	  exports: [RouterModule]
	})
	export class AppRoutingModule { }

	This configuration routes the root path (/) to the HomeComponent and /products to the ProductsComponent.
	
	
8. Forms: 
	Build interactive forms for user input. Use directives like ngModel for two-way data binding and validation directives for form validation.
	
	<form #myForm="ngForm" (ngSubmit)="onSubmit(myForm)">
	  <input type="text" name="name" [(ngModel)]="user.name" required>
	  <button type="submit">Submit</button>
	</form>

	This form binds the name input to the user.name property in the component's logic.
	
	
	
9. Http Client: 
	Used for making HTTP requests to backend APIs.
	
	import { HttpClient } from '@angular/common/http';

	constructor(private http: HttpClient) {}

	getProducts() {
	  return this.http.get<Product[]>('https://api.example.com/products');
	}

	The http service makes a GET request to the specified API endpoint and returns the fetched product data.
	
	

10. Observables: 
	Observables are a core concept in Angular's reactive programming approach to handling asynchronous data streams. They represent sequences of values that may be emitted over time.

	import { Observable, of } from 'rxjs';

	getProduct(id: number): Observable<Product> {
	  // Simulate asynchronous data retrieval
	  const products = [
		{ id: 1, name: 'T-Shirt', price: 19.99 },
		{ id: 2, name: 'Hat', price: 14.99 }
	  ];
	  const product = products.find(p => p.id === id);
	  return of(product); // Emit the product as an Observable
	}

	// In a component
	getProduct(id: number) {
	  this.productService.getProduct(id)
		.subscribe(product => this.currentProduct = product);
	}

	In this example, the getProduct method returns an Observable that emits the product data when subscribed to. The component subscribes to the Observable and updates its currentProduct property upon receiving the data.
	
Angular 18 new features :
	. Zoneless Change Detection: This experimental feature allows applications to opt-out of the traditional zone.js based change detection, potentially leading to better performance and simplified debugging.

	. Route Redirects with Functions: Instead of static strings, you can now define route redirects using functions. This enables more dynamic logic for handling redirects based on application state or other runtime information.

	. Improved Forms API: Angular 18 introduces new control state change events, making it easier to track and react to changes in form controls.

	. TypeScript 4.7 Support: Angular 18 embraces the latest features and improvements in TypeScript 4.7, including template literal types, enhanced readonly support, and new import types.

	. Other Enhancements: Several other improvements include a revamped AOT compilation process, better server-side rendering with hydration support, and elevated debugging experience with upgraded tooling.

===========================================================================================

Differrence between AngularJS and Angular : 
	AngularJS and Angular are both frameworks for building web applications, but they differ significantly in terms of design, structure, and features. Here are the key differences between AngularJS and Angular:
	
	1. Architecture
		. AngularJS (Angular 1.x):
			. Follows the Model-View-Controller (MVC) architecture.
			. The View is responsible for displaying data, the Controller handles business logic, and the Model manages data.
		
		. Angular (Angular 2+):
			. Follows a component-based architecture.
			. The application is built using reusable and encapsulated components, each with its own template, logic, and styles.
		
	2. Language
		. AngularJS:
			. Written in JavaScript.
			. Uses JavaScript for building applications.
		
		. Angular:
			. Written in TypeScript, a superset of JavaScript.
			. TypeScript provides static typing, classes, interfaces, and other features that help in building large-scale applications.

	3. Mobile Support
		. AngularJS:
			. Limited support for mobile development.
			. Not optimized for mobile performance and development.
			
		. Angular:
			. Designed with mobile support in mind.
			. Provides tools and features for building high-performance mobile applications.
	
	4. Performance
		. AngularJS:
			. Relatively slower due to its two-way data binding and digest cycle.
			. Handles large applications less efficiently.
		
		. Angular:
			. Improved performance with a more efficient change detection mechanism.
			. Uses one-way data binding and a hierarchical dependency injection system.
	
	5. Dependency Injection
		. AngularJS:
			. Has a built-in dependency injection system.
			. Services and components are injected using the $injector service.
		
		. Angular:
			. A more advanced and hierarchical dependency injection system.
			. Dependencies are provided and injected in a tree-shakable manner, improving performance.

	6. Directives
		. AngularJS:
			. Directives are used to extend HTML with custom behavior.
			. Two types: Built-in directives (e.g., ng-bind, ng-model) and custom directives.
		
		. Angular:
			. Directives are split into components and directives.
			. Components are a special type of directive with a template, while directives add behavior to existing DOM elements.

	7. Data Binding
		. AngularJS:
			. Two-way data binding.
			. Changes in the model update the view and vice versa automatically.
		
		. Angular:
			. One-way data binding by default, with optional two-way data binding using ngModel.
			. More predictable and easier to debug.

	8. Routing
		. AngularJS:
			. Uses the ngRoute module or third-party libraries like ui-router for routing.
		
		. Angular:
			. Uses the Angular Router, a more advanced and feature-rich routing module.
			. Supports lazy loading of modules, route guards, and more.

	9. Forms
		. AngularJS:
			. Forms are handled using ngModel and directives like ngForm.
		
		. Angular:
			. Provides both template-driven and reactive forms.
			. Reactive forms offer more control and flexibility for complex form scenarios.

	10. Community and Ecosystem
		. AngularJS:
			. Older framework with a large number of legacy applications.
			. Community support has decreased as focus has shifted to Angular.
		
		. Angular:
			.  Actively maintained and developed with a growing ecosystem.
			. Strong community support and frequent updates.

	11. Tooling and Development Experience
		. AngularJS:
			. Basic development tools and debugging support.
			. Relies on manual setup and configuration.
		
		. Angular:
			. Modern development tools like Angular CLI for scaffolding, building, and testing applications.
			. Integrated with tools like Webpack for module bundling and optimization.




	Example Comparison
		AngularJS Example:
			<!DOCTYPE html>
			<html ng-app="myApp">
			<head>
				<title>AngularJS Example</title>
				<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
				<script>
					var app = angular.module('myApp', []);
					app.controller('myController', function($scope) {
						$scope.message = "Hello, AngularJS!";
					});
				</script>
			</head>
			<body ng-controller="myController">
				<p>{{ message }}</p>
			</body>
			</html>
			
		Angular Example:
			<!-- app.component.html -->
			<p>{{ message }}</p>


			<!-- app.component.ts -->
			import { Component } from '@angular/core';

			@Component({
			  selector: 'app-root',
			  templateUrl: './app.component.html'
			})
			export class AppComponent {
			  message: string = "Hello, Angular!";
			}


			<!-- app.module.ts -->
			import { NgModule } from '@angular/core';
			import { BrowserModule } from '@angular/platform-browser';
			import { AppComponent } from './app.component';

			@NgModule({
			  declarations: [AppComponent],
			  imports: [BrowserModule],
			  bootstrap: [AppComponent]
			})
			export class AppModule { }


			<!-- main.ts -->
			import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
			import { AppModule } from './app.module';

			platformBrowserDynamic().bootstrapModule(AppModule);




===========================================================================================

In conclusion, Angular (2+) is a complete rewrite of AngularJS (1.x) with significant improvements in performance, maintainability, and scalability, making it more suitable for modern web application development.

===========================================================================================